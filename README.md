# 크래프톤 정글 Week 10

Status: 시작 전
담당자: 성헌, 넌 천, Hyeok Chang
마감일: 2023/06/26
상태: In progress
설명: 크래프톤 정글 WEEK 10 에 진행한 학습과 과정에 대한 기록.

# ✅ 키워드

---

<aside>
💡 Pintos Project3 : Virtual Memory

</aside>

## *Virtual memory management

- paging
    - virtual page
    - physical frame
    - page table & supplementary page table
- Memory Management Unit (MMU)
- Translation Lookaside Buffer (TLB)

## *Page type

- Uninitialized page
    - Lazy initialization
- Anonymous page
    - stack growth
- file-backed page
    - mmap syscall

## *Swap in/out

- page replacement policy
- swap disk

## *Copy on Write (COW)

# ✅ 요일 별 TODO

---

## 📆 23.06.12(월)

- [x]  팀 페이지 세팅
- [x]  git repositorty 만들기 (~ Project2까지 코드 병합)
- [x]  Project3 virtual memory 이론 학습
    - [x]  git book 번역

## 📆 23.06.13(화)

- [x]  Project3 virtual memory 이론 학습
    - [x]  git book 번역
- [x]  알고리즘 문제 풀이 (15:00 ~ 16:30)

## 📆 23.06.14(수)

- [x]  Project3 virtual memory 이론 학습
    - [x]  git book 번역 - instruction
    - [x]  키워드 학습
        - Virtual memory management
        - Page type
        - Swap in/out

## 📆 23.06.15(목)

- [x]  Project3 - Memory Management 과제 수행
    - [x]  supplemental page table 생성

## 📆 23.06.16(금)

- [x]  Project3 - Memory Management 과제 수행
    - Memory Management
    - Anonymous Page

## 📆 23.06.17(토)

- [x]  Project3 - Memory Management 과제 수행
    - Memory Management
    - Anonymous Page

## 📆 23.06.18(일)

- [x]  기존 pintos의 vm 관련 소스 정리
- [x]  anonymous page까지 구현 후 현재 vm 관련 소스 정리

## 📆 23.06.19(월)

- [ ]  Project3
    - Memory Management 테스트 디버깅
    - Stack growth
        - git book 해석 & 정독

## 📆 23.06.20(화)

- [ ]  Project3
    - Memory Management 테스트 디버깅
    - Stack growth

## 📆 23.06.21(수)

- [ ]  Project3
    - Stack growth
    - Memory Mapped Files
        - git book 해석 & 정독
    - Swap In/Out
        - git book 해석 & 정독

## 📆 23.06.22(목)

- [ ]  Project3
    - Stack growth
    - Memory Mapped Files
    - Swap In/Out

## 📆 23.06.23(금)

- [ ]  Project3
    - Stack growth
    - Memory Mapped Files
    - Swap In/Out

## 📆 23.06.24(토)

- [ ]  Project3
    - Stack growth
    - Memory Mapped Files
    - Swap In/Out
    - Copy-on-Write
        - git book 해석 & 정독

## 📆 23.06.25(일)

- [ ]  정리
    - 주요 학습 내용
    - 특이점
    - 트러블 슈팅
    - 발표 자료 정리

# ✅ 과제

---

<aside>
💡 git book을 바탕으로 과제 진행.

</aside>

## *Memory Management

## *****Anonymous Page****

# ✅ 알고가야 할 개념

---

<aside>
💡 Pintos Project 3을 진행하면서 알게된 개념들과 더 공부해야할 주제들을 정리.

</aside>

## 📚 Git Book 번역

## Introduction

## P**roject3: Virtual Memory**

이제 핀토스에 조금 익숙해졌을 것이다. 핀토스는 동기화를 통해서 실행 가능한 스레드를 스케줄링 할 수 있으며, 여러 개의 사용자 프로그램들을 동시에 로드할 수 있다. 그러나 실행할 수 있는 프로그램의 수와 크기는 주 기억 장치 크기에 의해 제한된다. 이번 프로젝트 3에서 illusion of infinite memory 이라는 것을 이용해서 이러한 제한을 제거해보자.

(project 3는 project 2를 기반으로 진행되므로 project 2에서의 테스트 프로그램은 project 3에서도 작동해야 한다. 즉, project 3 작업을 시작하기 전에 프로젝트 2 제출물의 버그를 수정하는 데 신경을 써야 한다. 그렇게 하지 않을 경우 project 3에서도 동일한 버그를 야기할 것이다.)

## Background

### Source Files

프로젝트 3은 /vm 디렉토리에서 작업한다. DO NOT CHANGE로 표시된 템플릿은 절대 변경하지 말아야 하며, 수정할 각 템플릿 파일에 대한 일부 세부 정보는 제공된다.

- `include/vm/vm.h`, `vm/vm.c`
    
    가상 메모리에 대한 일반적인 인터페이스를 제공한다. 헤더 파일에서는 가상 메모리 시스템이 지원해야 하는 다른 vm_type(VM_UNINIT, VM_ANON, VM_FILE, VM_PAGE_CACHE)에 대한 정의와 설명을 볼 수 있다. 여기서 보조 페이지 테이블을 구현해야 한다.
    
- `include/vm/uninit.h`, `vm/uninit.c`
    
    초기화 되지 않은 페이지에 대한 함수들을 제공한다. 현재의 설계에서는 모든 페이지가 초기에 미초기화된 페이지로 설정되며, 이후 익명 페이지 또는 파일 지원 페이지로 변환된다.
    
- `include/vm/anon.h`, `vm/anon.c`
    
    익명 페이지에 대한 함수들을 제공한다. (vm_type = VM_ANON)
    
- `include/vm/file.h`, `vm/file.c` (vm_type = VM_FILE)
    
    파일을 지원하는 페이지에 대한 함수들을 제공한다.
    
- `include/vm/inspect.h`, `vm/inspect.c`
    
     이 파일들에는 평가를 위한 메모리 검사 함수들이 포함되어 있다. 이 파일은 변경해서는 안된다.
    

이 프로젝트에서 작성하는 대부분의 코드는 vm 디렉토리에 있는 파일과 이전 프로젝트에서 소개된 파일들이다. 처음 접하는 파일은 다음과 같다.

- `include/devices/block.h`, `devices/block.c`
    
    이 파일들에 있는 인터페이스들은 블록 장치를 섹터 단위로 읽고 쓰는 작업을 가능하게 한다. 이를 이용해서 스왑 파티션에 블록 장치로 접근할 수 있다. 즉 스왑 파티션에 데이터를 읽거나 쓸 수 있게 된다.
    

### Memory Terminology

우리는 메모리와 저장소에 대한 일부 용어들을 제시한 후에 프로젝트를 시작할 것이다. 이 용어들 중 일부는 프로젝트 2에서 많이 사용했던 것일 수도 있다.(see [Virtual Memory Layout](https://casys-kaist.github.io/pintos-kaist/project2/introduction.html)), 하지만 그 중 많은 부분은 새로운 내용이다.

### **Pages**

페이지는 메모리의 작은 단위로, 가상 메모리에서 4,096바이트 크기로 구성된 연속된 영역을 말한다. 프로그램이 메모리를 사용할 때 페이지 단위로 분할되어 할당된다. 페이지 크기는 일반적으로 하드웨어나 운영 체제에 의해 정의되며, 이는 작업을 수행하는 데 필요한 최소한의 메모리 단위이다. 

페이지는 페이지 정렬, 즉 페이지 크기로 나누어 떨어지는 가상 주소에서 시작해야 한다. 예를 들어, 페이지 크기가 4,096 바이트인 경우, 페이지는 4,096, 8,192, 12,288와 같이 4,096로 나누어 떨어지는 가상 주소에서 시작해야 한다. 페이지 크기로 나누어 떨어지지 않는 가상 주소에서 페이지를 시작하면 페이지 경계를 넘어서는 문제가 발생할 수 있다. (64비트 가상 주소의 마지막 12비트는 페이지 내에서의 오프셋을 나타냅니다. 이 오프셋은 페이지의 시작 위치부터 몇 바이트나 떨어져 있는지를 나타내는 값이다.)

상위 비트는 곧 소개될 페이지 테이블에서의 인덱스를 나타내는 데 사용된다. 64비트 시스템에서는 4단계 페이지 테이블을 사용하며, 이는 가상 주소를 다음과 같이 보이게 한다.

```c
63          48 47            39 38            30 29            21 20         12 11         0
+-------------+----------------+----------------+----------------+-------------+------------+
| Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |    Page    |
|             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
+-------------+----------------+----------------+----------------+-------------+------------+
              |                |                |                |             |            |
              +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                          Virtual Address
```

각 프로세스는 자체적으로 독립적인 가상 페이지 집합을 갖는다. 사용자 페이지는 KERN_BASE (0x8004000000) 아래에 위치한 페이지들을 말한다. 즉 KERN_BASE 주소보다 작은 가상 주소 영역에 있는 페이지들은 해당 프로세스의 사용자 페이지로 사용된다. 이를 통해서 각 프로세스는 자신만의 가상 메모리 공간을 사용하게 된다.

한편, 커널 가상 페이지의 집합은 전역적이며, 어떤 스레드나 프로세스가 실행 중인지에 관계없이 항상 동일한 위치에 유지된다. (가상 메모리는 **사용자 페이지**와 **커널 페이지**로 나뉜다. 각각의 프로세스는 자체적인 사용자 페이지를 갖고 있으며, 이 페이지들은 해당 프로세스의 독립적인 가상 메모리 공간으로 사용된다. 반면에  이를 통해서 사용자와 커널 간에 메모리를 분리하고 보안을 강화할 수 있다.) **커널은 사용자 페이지와 커널 페이지에 모두 접근할 수 있지만, 사용자 프로세스는 자신의 사용자 페이지에만 접근할 수 있다.**

(Pintos는 가상 주소를 다루기 위한 여러 유용한 함수를 제공한다. 자세한 내용은 '가상 주소' 섹션을 참조하자.)

### **Frames**

프레임은 물리 메모리의 연속된 영역으로, 때때로 물리적 프레임 또는 페이지 프레임이라고도 불린다. 프레임의 크기는 페이지의 크기와 동일해야 하고, 물리 메모리에서 페이지 크기와 정렬에 맞춰 할당된다.

즉, 프레임을 물리 메모리에서의 페이지라고 생각하면 될 것 같다. 가상 메모리 시스템에서 페이지는 가상 주소 공간에서 사용되고, 해당 페이지는 물리 메모리에서 프레임에 매핑된다. 이를 통해서 가상 주소 공간의 페이지를 물리 메모리에 매핑하고, 프로세스는 이를 통해 메모리에 접근할 수 있게 된다.

따라서, 64비트 물리 메모리 주소는 프레임 번호와 프레임 오프셋으로 나눌 수 있다. 이를 표현해보자면 다음과 같다.

```c
                          12 11         0
    +-----------------------+-----------+
    |      Frame Number     |   Offset  |
    +-----------------------+-----------+
              Physical Address
```

 x86-64 아키텍처에서 물리 메모리 주소에 직접적으로 접근할 수 있는 방법은 없다. 핀토스는 이를 극복하기 위해서 **커널 가상 메모리를 물리 메모리에 직접 매핑한다.** 커널 가상 메모리의 첫 번째 페이지는 물리 메모리의 첫 번째 프레임에 매핑되고, 두 번째 페이지는 두 번째 프레임에 매핑되는 식으로 이루어진다. 따라서, 프레임은 커널 가상 메모리를 통해 접근할 수 있다.

(핀토스는 물리 메모리 주소와 커널 가상 주소 간의 변환을 위한 함수를 제공하고 있다. 이 또한 자세한 내용은 '가상 주소' 섹션을 참조하자.)

### **Page Tables**

**페이지 테이블이란? CPU가 가상 주소를 물리 주소로 변환하는 데 사용하는 데이터 구조**라고 할 수 있다. 즉, CPU는 가상 주소가 속한 페이지를 해당 페이지가 매핑된 프레임으로 변환하여 실제 물리 메모리 주소를 얻게 된다. 이러한 가상 주소와 물리 주소 간의 변환은 페이지 테이블을 통해 이루어진다. 페이지 테이블의 형식은 x86-64 아키텍처에 정의되어 있다.

`threads/mmu.c` 파일에 페이지 테이블 관리 코드를 제공한다. 이 코드들은 핀토스 시스템에서 페이지 테이블을 관리하고, 가상 주소를 물리 주소로 변환하는 데 사용된다. 

아래의 다이어그램은 페이지와 프레임 간의 관계를 보여준다. 왼쪽에 있는 가상 주소는 페이지 번호와 오프셋으로 구성되어 있으며, 페이지 테이블을 통해 페이지 번호가 프레임 번호로 변환된다. 이 프레임 번호와 오프셋이 결합되어 물리 주소를 얻게 된다 즉, 가상 주소를 통해서 페이지와 프레임 간의 매핑이 이루어지며, 이를 통해서 물리 메모리 주소를 얻을 수 있게 된다.

```c
                          +----------+
         .--------------->|Page Table|-----------.
        /                 +----------+            |
        |   12 11 0                               V  12 11 0
    +---------+----+                         +---------+----+
    | Page Nr | Ofs|                         |Frame Nr | Ofs|
    +---------+----+                         +---------+----+
     Virt Addr   |                            Phys Addr    ^
                  \_______________________________________/
```

### Swap Slots

스왑 슬롯이란? 스왑 파티션에 있는 페이지 크기의 디스크 공간 영역이다. 

프레임은 물리 메모리에 직접적으로 매핑되는 메모리 영역으로, 프레임의 크기와 정렬은 하드웨어 제약에 따라 결정된다. 이는 특정 하드웨어 아키텍처에서 정해진 메모리 관리 방식에 따라 프레임이 할당되고 사용되어야 함을 의미한다.

반면에 스왑 슬롯은 디스크의 스왑 파티션에 저장되는 영역이며, 스왑 슬롯의 배치에 대한 하드웨어 제약은 상대적으로 유연하다. 즉, 스왑 슬롯이 디스크에 저장될 때, 프레임에 비해 상대적으로 자유롭게 배치될 수 있다. 이는 스왑 슬롯의 크기와 정렬에 대한 제약이 프레임보다 더 유연하게 적용될 수 있음을 의미한다.

따라서, 스왑 슬록은 하드웨어적인 제약이 비교적 유연하게 적용될 수 있기 때문에 스왑 파티션의 디스크 공간을 효율적으로 관리하고, 스왑 공간의 사용을 최적화하는 데에 도움을 줄 수 있다.

### Resource Management Overview

우리는 다음과 같은 데이터 구조를 설계/구현해야 한다. 

**Supplemental page table**

- 페이지 테이블을 보완해서 페이지 폴트 처리를 가능하게 한다. 즉, 메모리 관리에서 페이지 폴트가 발생했을 때, 보충 페이지 테이블을 통해서 누락된 페이지를 식별하고 필요한 프레임을 할당하여 메모리에 로드하는 역할을 수행한다.

**Frame table**

- 물리적인 프레임의 eviction(대체) 정책을 효율적으로 구현하는 데 사용된다.
- 프레임 테이블은 메모리 관리에서 어떤 프레임을 대체할 것인지를 결정하는 데 필요한 정보를 담고 있다. 이를 통해서 대체 정책을 구현하고 메모리의 효율을 높인다.

**Swap table**

- 스왑 슬롯의 사용 상태를 추적하는데 사용된다.
- 스왑 슬롯은 디스크의 스왑 파티션에 저장되는 페이지와 프레임의 대응 관계를 유지하기 위해 사용된다. 스왑 테이블은 어떤 스왑 슬롯이 현재 사용 중인지 추적하여 관리한다.

위의 세가지 데이터 구조를 완전히 독립된 구조로 구현할 필요는 없으며, 관련된 리소스를 하나로 통합해서 사용하는 편이 편리할 수 있다. 예를 들어 관련된 정보를 담는 하나의 통합 데이터 구조를 설계하거나, 한 데이터 구조 내에서 서로 연관된 데이터 필드를 가지도록 설계하는 등의 접근 방식을 고려할 수 있다. 

각 위의 데이터 구조마다 각 요소가 **어떤 정보를 포함해야 하는지 결정**해야 한다. 즉, 각 데이터 구조가 어떤 데이터를 저장하고 조작해야 하는지 정의해야 한다는 것을 뜻한다. 또한 **데이터 구조의 범위를 결정**해야 한다. 데이터 구조가 로컬 범위(프로세스 단위)에만 적용이 되는지 아니면 글로벌 범위(전체 시스템)에 적용되는지를 결정하자. 그리고 마지막으로 해당 범위 내에서 필요한 **인스턴스의 개수를 결정**해야 한다. 즉, 데이터 구조를 몇 개의 인스턴스로 구성해야 하는지를 결정하자 (이는 해당 범위 내에서 동시에 필요한 독립적인 데이터 구조의 개수를 의미한다.)

따라서 데이터 구조의 설계와 구현 시에 각 요소의 정보, 범위 그리고 필요한 인스턴스의 개수를 결정해야 한다. 이는 데이터 구조의 목적과 사용되는 컨텍스트에 따라 결정된다.

설계를 단순화하기 위해 이러한 데이터 구조를 페이링 할 수 없는 메모리 (calloc이나 malloc으로 할당된 메모리)에 저장하자. 이렇게 함으로써 포인터 유효성을 보장할 수 있다.

(일반적으로 페이지화 되지 않는 메모리는 운영 체제의 가상 메모리 관리 시스템에 의해 페이지 스왑 아웃되지 않고 메모리에 상주하도록 지정된 메모리 영역이다. 이는 데이터 구조가 물리적인 메모리에 위치함을 의미하며, 페이지 폴트가 발생하지 않는다는 것을 의미한다. 따라서 포인터를 통해 서로 연결된 데이터 구조의 주소가 변경되지 않고 유지될 수 있다. )

### Choices of implementation (Performance perspective)

구현에 가능한 선택지로는 배열, 리스트, 비트맵, 해시 테이블이 있다. 배열은 종종 가장 간단한 접근 방식이지만, 구성 요소가 희소하게 분포된 배열은 메모리를 낭비한다. 리스트 또한 간단하지만 특정 위치를 찾기 위해 긴 리스트를 탐색하는 것은 시간을 낭비한다. 배열과 리스트 모두 크기를 조정할 수 있지만, 리스트는 가운데에 삽입 및 삭제를 더 효율적으로 지원한다.

`lib/kernel/bitmap.c`와 `include/lib/kernel/bitmap.h`에 비트맵 데이터 구조가 포함되어 있다. 비트맵은 각각이 true 또는 false가 될 수 있는 비트의 배열이다. 비트맵은 일련의 자원의 사용 상태를 추적하는 데 일반적으로 사용된다. 자원 n이 사용 중이면 비트맵의 n번째 비트는 `true`이다. 핀토스의 비트맵은 크기가 고정되어 있으나, 크기 조정을 지원하도록 구현을 확장할 수 있다.

Pintos에는 해시 테이블 데이터 구조도 포함되어 있다. 해시 테이블은 삽입과 삭제를 다양한 크기의 테이블에 대해 효율적으로 지원한다.

더 복잡한 데이터 구조는 성능이나 기타 이점을 가져올 수 있지만, 구현을 불필요하게 복잡하게 만들 수도 있다. 따라서, 디자인의 일부로 고급 데이터 구조 (예: 균형 이진 트리)를 구현하는 것을 권장하지 않는다.

 

## ****Managing the Supplemental Page Table****

Supplemental Page Table은 각 페이지에 대한 추가 데이터로 페이지 테이블을 보완한다. 이는 페이지 테이블의 형식 때문에 발생한 제약 때문이다. (이와 같은 데이터 구조는 페이지 테이블이라고도 불리우기 때문에 혼동을 줄이기 위해 보충적이라는 단어를 추가한다.)

Supplemental Page Table은 적어도 두 가지 목적으로 사용된다. 가장 중요한 목적은 페이지 폴트가 발생했을 때, 커널이 보충 페이지 테이블에서 해당하는 가상 페이지를 찾아 어떤 데이터가 있어야 하는지 확인하는 것이다. 두 번째 목적은 프로세스가 종료될 때 커널은 어떤 자원을 해제해야 하는지 결정하기 위해 Supplemental Page Table을 참조한다.

### ****Organization of Supplemental Page Table****

Supplemental Page Table의 구성은 사용자의 요구에 맞게 자유롭게 조직될 수 있으며, 기본적으로 **세그먼트** 또는 페이지를 기준으로 구성할 수 있다. 세그먼트는 연속된 페이지의 그룹으로 이해되며, 실행 가능한 파일이나 메모리 매핑된 파일과 같은 메모리 영역을 나타냅니다.

(선택적으로 Supplemental Page Table의 멤버를 추적하기 위해 페이지 테이블 자체를 사용할 수 있다. 이를 위해서 `threads/mmu.c`에 있는 Pintos 페이지 테이블 구현을 수정해야 한다. 이 접근 방식은 어려우므로 초보 학생들에게는 권장하지 않는다.)

### ****Handling page fault****

Supplemental Page Table의 가장 중요한 기능은 페이지 폴트 핸들러이다. 프로젝트 2에서는 페이지 폴트가 항상 커널이나 사용자 프로그램의 버그를 나타냈지만 프로젝트 3부터는 페이지 폴트가 페이지를 파일이나 스왑 슬롯에서 가져와야 함을 나타낼 수도 있다. 이러한 경우를 처리하기 위해 더 복잡한 페이지 폴트 핸들러를 구현해야 한다.

페이지 폴트 핸들러는 `userprog/exception.c` 파일에 있는 `page_fault()` 함수이고, `vm/vm.c` 파일에 있는 `vm_try_handle_fault()` 함수를 호출한다. 페이지 폴트 핸들러는 대략적으로 다음 작업을 수행해야 한다.

1. 페이지 폴트 핸들러는 Supplemental Page Table에서 폴트가 발생한 페이지를 찾은 다음, 해당 페이지에 들어갈 데이터를 Supplemental Page Table 항목을 사용하여 찾는다. 데이터는 파일 시스템이나 스왑 슬롯에 있을 수 있으며, 페이지가 읽기 전용인 경우 데이터는 모두 0인 페이지일 수도 있다. 공유(Copy-on-Write)가 구현된 경우 페이지의 데이터는 페이지 프레임에 이미 존재할 수 있지만 페이지 테이블에는 없을 수도 있다. 만약 보충 페이지 테이블이 사용자 프로세스가 접근하려는 주소에 데이터가 없거나 페이지가 커널 가상 메모리에 있거나 읽기 전용 페이지에 대한 쓰기 시도인 경우, 접근은 잘못된 것으로 간주된다. 잘못된 접근이 발생한 경우 프로세스는 종료되며, 모든 리소스가 해제된다.
2. 페이지를 저장할 프레임을 얻는다. 공유 기능을 구현한 경우, 필요한 데이터가 이미 프레임에 있는 경우 해당 프레임을 찾을 수 있어야 한다.
3. 데이터를 가져와서 프레임에 넣는다. 이를 위해 파일 시스템이나 스왑에서 읽거나 0으로 초기화하는 등의 작업을 수행한다. 공유 기능을 구현한 경우, 필요한 페이지가 이미 프레임에 있는 경우에는 이 단계에서 추가 작업이 필요하지 않다.
4. 페이지 폴트가 발생한 가상 주소에 대한 페이지 테이블 항목을 해당 물리 페이지로 연결한다. 이를 위해 `threads/mmu.c` 파일의 함수를 사용할 수 있다.

## Managing the Swap Table

스왑 테이블은 사용 중인 스왑 슬롯과 빈 스왑 슬롯을 추적하며, 페이지를 스왑 파티션으로 이동시키는 데 사용할 수 있는 빈 스왑 슬롯을 선택하는 기능을 제공해야 한다. 또한, 해당 페이지가 다시 읽혀질 때나 페이지가 스왑되었던 프로세스가 종료될 때 해당 스왑 슬롯을 해제할 수 있어야 한다.

`vm/build` 디렉토리에서 명령어 pintos-mkdisk swap.dsk --swap-size=n을 사용하여 swap.dsk라는 디스크를 생성합니다. 이 디스크에는 n-MB 크기의 스왑 파티션이 포함된다. 그 이후에 pintos를 실행할 때 swap.dsk가 자동으로 추가 디스크로 연결된다. 대신, --swap-size=n 옵션을 사용하여 pintos에 임시 n-MB 스왑 디스크를 사용하도록 설정할 수 있다. 이는 단일 실행에 대해서만 적용된다.

스왑 슬롯은 필요할 때만 할당되어야 하며, 프로세스 시작 시 실행 파일에서 데이터 페이지를 즉시 스왑에 쓰는 것은 좋지 않다. 특정 페이지를 저장하기 위해 스왑 슬롯을 예약해서는 안 되며, 스왑 슬롯의 내용이 프레임으로 다시 읽혀질 때 해당 스왑 슬롯을 해제해야 한다.

## ****Managing Memory Mapped Files****

파일 시스템은 일반적으로 읽기와 쓰기 시스템 호출을 통해 접근되지만, 두 번째 인터페이스로는 mmap 시스템 호출을 사용하여 파일을 가상 페이지로 매핑할 수 있다. 이후 프로그램은 파일 데이터에 직접 메모리 명령을 사용할 수 있게 된다. 예를 들어, 파일 'foo'가 0x1000 바이트(4 kB 또는 한 페이지)라고 가정하고, 'foo'가 주소 0x5000에서 시작하여 메모리에 매핑된다면, 0x5000부터 0x5fff까지의 메모리 접근은 'foo'의 해당 바이트에 접근하게 된다.

아래의 프로그램은 명령 줄에 지정된 파일을 열고, 해당 파일을 가상 주소 0x10000000에 매핑한다. 그런 다음 매핑된 데이터를 콘솔(fd 1)에 출력하고, 파일의 매핑을 해제한다.

```c
#include <stdio.h>
#include <syscall.h>

int main (int argc UNUSED, char *argv[]) {
  void *data = (void *) 0x10000000;                 /* Address at which to map. */
  int fd = open (argv[1]);                          /* Open file. */
  void *map = mmap (data, filesize (fd), 0, fd, 0); /* Map file. */

  write (1, data, filesize (fd));                   /* Write file to console. */
  munmap (map);                                     /* Unmap file (optional). */

  return 0;
}
```

우리가 구현한 코드는 메모리 맵 파일에 의해 사용되는 메모리를 추적할 수 있어야 하며, 매핑된 영역에서의 페이지 폴트를 올바르게 처리하고 매핑된 파일이 다른 세그먼트와 겹치지 않도록 보장해야 한다.

## Memory Management

가상 메모리 시스템을 지원하기 위해서 가상 메모리의 상의 페이지와 물리 메모리 상의 프레임을 효과적으로 관리해야 한다. 이는 사용 중인 메모리 영역이 어떤 목적으로 누구에 의해 사용되는지 등을 추적해야 한다는 것을 의미한다. 

먼저 supplemental page table을 다루고 그 다음으로 물리 메모리 상의 프레임을 다룰 것이다. 이해를 돕기 위해 가상 메모리에서는 페이지라는 용어를 사용하고, 물리 메모리에서는 프레임이라는 용어를 사용한다.

## Page Structure and Operations

### Struct page

`include/vm/vm.h`에 정의된 페이지는 가상 메모리에서 페이지를 나타내는 구조체다. 이 구조체는 페이지에 대한 모든 필요한 데이터를 저장한다. 현재는 다음과 같이 구조체가 정의되어 있다.

```c
struct page {
  const struct page_operations *operations;
  void *va;              /* Address in terms of user space */
  struct frame *frame;   /* Back reference for frame */

  union {
    struct uninit_page uninit;
    struct anon_page anon;
    struct file_page file;
#ifdef EFILESYS
    struct page_cache page_cache;
#endif
  };
};
```

이 구조체는 Page Operations(아래 참조)을 가지고 있으며, 가상 주소와 물리적 프레임도 가지고 있습니다. 또한, 이 구조체에는 union 필드가 있습니다. union은 메모리 영역에 다른 유형의 데이터를 저장할 수 있는 특수한 데이터 형식입니다. union에는 여러 개의 멤버가 있지만, 한 번에 하나의 멤버만 값을 포함할 수 있습니다. 

이는 우리 시스템의 페이지가 uninit_page, anon_page, file_page, 또는 page_cache가 될 수 있다는 것을 의미합니다. 

예를 들어, 페이지가 익명 페이지인 경우 (Anonymous Page 참조), 페이지 구조체에는 struct anon_page anon 필드가 멤버로 포함됩니다. anon_page에는 익명 페이지에 대해 유지해야 하는 모든 필요한 정보가 포함됩니다.

### Page Operations

위에서 설명한 대로 `include/vm/vm.h`에서 정의된 대로, 페이지는 VM_UNINIT, VM_ANON, 또는 VM_FILE일 수 있습니다. 페이지에는 스왑 인, 스왑 아웃, 페이지 파괴와 같은 여러 동작이 필요합니다. 각 페이지 유형마다 이러한 동작에 대해 필요한 단계와 작업이 다릅니다. 

다시 말해, VM_ANON 페이지와 VM_FILE 페이지에 대해 서로 다른 파괴 함수를 호출해야 합니다. 각 함수에서 각 경우를 처리하기 위해 switch-case 구문을 사용하는 것이 한 가지 방법입니다.

이를 처리하기 위해 우리는 객체지향 프로그래밍의 '클래스 상속' 개념을 도입합니다. 실제로 C 프로그래밍 언어에서는 '클래스'나 '상속'이 없으므로, Linux와 같은 실제 운영 체제 코드에서와 비슷한 방식으로 함수 포인터를 사용하여 이러한 개념을 구현합니다.

함수 포인터는 메모리 내의 함수 또는 실행 가능한 코드를 가리키는 다른 포인터와 마찬가지로 포인터입니다. 함수 포인터는 런타임 값에 따라 특정 함수를 호출하여 실행하는 간단한 방법을 제공하기 때문에 유용합니다. 어떠한 확인도 필요하지 않습니다. 우리의 경우에는 코드 수준에서 destroy(page)를 호출하는 것만으로도 충분하며, 컴파일러는 올바른 함수 포인터를 호출하여 페이지 유형에 따라 적절한 destroy 루틴을 선택할 것입니다.

페이지 동작을 위한 구조체인 **`struct page_operations`**가 **`include/vm/vm.h`**에 정의되어 있습니다. 이 구조체를 함수 포인터가 3개 있는 함수 테이블로 생각해보세요.

```c
struct page_operations {
  bool (*swap_in) (struct page *, void *);
  bool (*swap_out) (struct page *);
  void (*destroy) (struct page *);
  enum vm_type type;
};
```

이제 **`page_operations`** 구조체를 어디에서 찾을 수 있는지 살펴봅시다. **`include/vm/vm.h`** 파일에서 **`struct page`**라는 **`page`** 구조체를 보면, **`operations`**라는 필드가 있는 것을 볼 수 있습니다. 이제 **`vm/file.c`**로 이동하면, **`page_operations`** 구조체인 **`file_ops`**의 선언을 볼 수 있습니다. 이는 파일을 기반으로 하는 페이지에 대한 함수 포인터 테이블입니다. 이 구조체의 **`destroy`** 필드는 **`file_backed_destroy`** 함수를 가리키고 있는데, 이 함수는 같은 파일에 정의되어 있는 페이지를 파괴하는 함수입니다.

함수 포인터 인터페이스를 통해 **`file_backed_destroy`**가 어떻게 호출되는지 이해해보겠습니다. 가정해보자면, **`vm/vm.c`**에서 **`vm_dealloc_page(page)`**가 호출되고, 이 **`page`**가 파일을 기반으로 한 페이지 (**`VM_FILE`**)인 경우입니다. 함수 내부에서 **`destroy(page)`**를 호출합니다. **`destroy(page)`**는 다음과 같은 형태의 매크로로 **`include/vm/vm.h`**에 정의되어 있습니다.

```c
#define destroy(page) if ((page)->operations->destroy) (page)->operations->destroy (page)
```

**`destroy`** 함수를 호출하면 실제로 **`(page)->operations->destroy(page)`**가 호출되며, 이는 페이지 구조체에서 검색된 destroy 함수입니다. 해당 페이지가 **`VM_FILE`** 페이지이므로, **`.destroy`** 필드는 **`file_backed_destroy`**를 가리킵니다. 결과적으로, 파일 기반 페이지에 대한 destroy 루틴이 수행됩니다.

## ****Implement Supplemental Page Table****

현재 시점에서, Pintos에는 가상 메모리의 물리 메모리 매핑을 관리하기 위한 페이지 테이블 (pml4)이 있습니다. 하지만, 이것만으로는 충분하지 않습니다. 이전 섹션에서 논의한 대로, 페이지 폴트와 리소스 관리를 처리하고, 각 페이지에 대한 추가 정보를 보유하기 위해 보충 페이지 테이블을 구현해야 합니다. 따라서, 우리는 프로젝트 3의 첫 번째 작업으로 보충 페이지 테이블에 대한 몇 가지 기본 기능을 구현하는 것을 제안합니다.

**Implement supplemental page table management functions in `vm/vm.c`.**

먼저 Pintos에서 보충 페이지 테이블을 어떻게 설계할지 결정해야 합니다. 자체적으로 보충 페이지 테이블을 설계한 후, 해당 설계에 따라 다음 세 가지 함수를 구현하십시오.

---

`void supplemental_page_table_init (struct supplemental_page_table *spt);`

> 보충 페이지 테이블을 초기화합니다. 보충 페이지 테이블에 사용할 데이터 구조를 선택할 수 있습니다. 이 함수는 새로운 프로세스가 시작될 때(`initd` 함수 내에서)와 프로세스가 포크될 때(`__do_fork` 함수 내에서) 호출됩니다.
> 

---

`struct page *spt_find_page (struct supplemental_page_table *spt, void *va);`

> 인자로 주어진 보충 페이지 테이블에서 `va`에 해당하는 `struct page`를 찾습니다. 실패할 경우 NULL을 반환합니다.
> 

---

`bool spt_insert_page (struct supplemental_page_table *spt, struct page *page);`

> 인자로 주어진 보충 페이지 테이블에 `struct page`를 삽입합니다. 이 함수는 주어진 보충 페이지 테이블에 가상 주소가 존재하지 않는지 확인해야 합니다.
> 

---

## Frame Management

이제부터 모든 페이지는 단순히 구성 시점의 메모리의 메타 데이터만을 담고 있는 것이 아닙니다. 따라서 물리 메모리를 관리하기 위해 다른 방식이 필요합니다. `include/vm/vm.h`에는 물리 메모리를 나타내는 `struct frame`이 존재합니다. 현재 이 구조체는 다음과 같이 정의되어 있습니다.

```c
/* The representation of "frame" */
struct frame {
  void *kva;
  struct page *page;
};
```

이 구조체는 `kva`라는 커널 가상 주소와 `page`라는 페이지 구조체 두 개의 필드만을 가지고 있습니다. 프레임 관리 인터페이스를 구현하는 과정에서 필요에 따라 멤버를 추가할 수 있습니다.

**Implement `vm_get_frame`, `vm_claim_page` and `vm_do_claim_page` in `vm/vm.c`.**

---

`static struct frame *vm_get_frame (void);`

> palloc_get_page를 호출하여 사용자 풀에서 새로운 물리 페이지를 얻습니다. 사용자 풀에서 페이지를 성공적으로 얻으면 프레임을 할당하고, 멤버를 초기화한 후에 반환합니다. vm_get_frame을 구현한 이후에는 모든 사용자 공간 페이지 (PALLOC_USER)를 이 함수를 통해 할당해야 합니다. 페이지 할당에 실패하는 경우에는 현재 스왑 아웃을 처리할 필요가 없습니다. 단지 해당 경우를 PANIC("todo")로 표시해주면 됩니다.
> 

---

`bool vm_do_claim_page (struct page *page);`

> Claims는 물리 프레임과 페이지를 할당하는 것을 의미합니다. 먼저 `vm_get_frame`을 호출하여 프레임을 얻습니다 (이 부분은 이미 템플릿에서 구현되어 있습니다). 그런 다음 MMU를 설정해야 합니다. 즉, 가상 주소와 물리 주소의 매핑을 페이지 테이블에 추가해야 합니다. 반환값은 작업이 성공했는지 여부를 나타내어야 합니다.
> 

---

`bool vm_claim_page (void *va);`

> 해당 가상 주소(va)에 페이지를 할당합니다. 먼저 페이지를 얻은 다음, 해당 페이지를 vm_do_claim_page 함수에 전달합니다.
> 

---

## ****Anonymous Page****

*이 프로젝트의 이 부분에서는 익명 페이지* 라는 비디스크 기반 이미지를 구현합니다 .

익명 매핑에는 백업 파일이나 장치가 없습니다. 파일 기반 페이지와 달리 명명된 파일 소스가 없기 때문에 익명입니다. 익명 페이지는 스택 및 힙과 같은 실행 파일에서 사용됩니다.

`include/vm/anon.h` 에는 익명 페이지를 설명하는 구조체인 **`anon_page`**가 있습니다. 현재는 비어 있지만 구현을 진행하면서 필요한 정보나 익명 페이지의 상태를 저장하는 멤버를 추가할 수 있습니다. 또한, `include/vm/page.h`에 있는 **`struct page`**를 살펴보세요. 이 구조체는 페이지의 일반적인 정보를 포함하고 있습니다. 익명 페이지의 경우, 해당 페이지 구조체에 **`struct anon_page anon`**이 포함되어 있습니다.

### ****Page Initialization with Lazy Loading****

**Lazy loading**은 **메모리 로딩을 필요한 시점까지 지연시키는 디자인**입니다. 페이지가 할당되어 있지만 해당 페이지에 대응하는 전용 물리 프레임은 없으며, 페이지의 실제 내용은 아직 로드되지 않은 상태입니다. **내용은 페이지 폴트에 의해 실제로 필요한 시점에만 로드됩니다.**

세 가지 종류의 페이지 유형이 있기 때문에 각 페이지에 대한 초기화 루틴이 다릅니다. 아래 섹션에서 다시 설명하겠지만, 여기에서는 페이지 초기화 흐름에 대한 수준높은 개요를 제공합니다. 먼저, 커널이 새 페이지 요청을 받으면 vm_alloc_page_with_initializer가 호출됩니다. 이 초기화 루틴은 페이지 구조체를 할당하고 페이지 유형에 따라 적절한 초기화 함수를 설정한 후 제어를 사용자 프로그램에 반환합니다. 사용자 프로그램이 실행되는 동안 어느 시점에서 페이지 폴트가 발생하면, 프로그램이 접근하려는 페이지가 아직 내용이 없는 경우입니다. 폴트 처리 절차 중에 uninit_initialize가 호출되고, 이전에 설정한 초기화 함수가 호출됩니다. 익명 페이지의 경우는 anon_initializer가 사용되고, 파일을 기반으로 한 페이지의 경우 file_backed_initializer가 사용됩니다.

한 페이지는 초기화(initialize) → (페이지 폴트(page_fault) → 게으른 로딩(lazy-load) → 스왑인(swap-in) → 스왑아웃(swap-out) → ...) → 소멸(destroy)의 라이프 사이클을 가질 수 있습니다. 라이프 사이클의 각 전환마다 페이지 유형(또는 VM_TYPE)에 따라 필요한 절차가 다르며, 앞선 문단은 초기화에 대한 예시였습니다. 이 프로젝트에서는 각 페이지 유형에 대해 이러한 전환 과정을 구현하게 됩니다.

### ****Lazy Loading for Executable****

Lazy loading은 메모리 로딩을 필요한 시점까지 지연시키는 디자인입니다. 페이지가 할당되어 있지만 해당 페이지에 대응하는 전용 물리 프레임은 없으며, 페이지의 실제 내용은 아직 로드되지 않은 상태입니다. 내용은 페이지 폴트에 의해 실제로 필요한 시점에만 로드됩니다.

Lazy loading을 지원하기 위해, `include/vm/vm.h`에 `VM_UNINIT`라는 페이지 유형을 도입합니다. **모든 페이지는 초기에 `VM_UNINIT` 페이지로 생성됩니다.** 또한, `include/vm/uninit.h`에는 초기화되지 않은 페이지를 위한 구조체 `uninit_page`가 제공됩니다. 초기화되지 않은 페이지를 생성, 초기화 및 파괴하기 위한 함수는 `include/vm/uninit.c`에 있습니다. 나중에 이러한 함수들을 완성해야 합니다.

페이지 폴트가 발생하면 페이지 폴트 핸들러인 `userprog/exception.c`의 `page_fault`가 `vm/vm.c`의 `vm_try_handle_fault`로 제어를 전달합니다. 이 함수는 먼저 유효한 페이지 폴트인지 확인합니다. 여기서 유효한 페이지 폴트란 잘못된 접근을 의미합니다. 만약 잘못된 페이지 폴트라면 페이지에 어떤 내용을 로드하고 사용자 프로그램으로 제어를 반환합니다.

부정확한 페이지 폴트에는 세 가지 경우가 있습니다: 레이지 로딩된 페이지, 스왑된 페이지, 그리고 쓰기 보호된 페이지 (Copy-on-Write (Exrtra) 참조). 현재는 첫 번째 경우인 레이지 로딩된 페이지만 고려합니다. lazy loading을 위한 페이지 폴트라면, 커널은 이전에 설정한 초기화 함수 중 하나인 `vm_alloc_page_with_initializer`를 호출하여 세그먼트를 lazy loading합니다. 이에 대한 구현은 `userprog/process.c`에서 `lazy_load_segment`를 완성해야 합니다.

`vm_alloc_page_with_initializer()` 함수를 구현해야 합니다. 전달된 `vm_type`에 따라 적절한 초기화 함수를 가져와 `uninit_new`를 호출해야 합니다.

```c
bool vm_alloc_page_with_initializer (enum vm_type type, void *va,
        bool writable, vm_initializer *init, void *aux);
```

주어진 타입으로 초기화되지 않은 페이지를 생성합니다. uninit 페이지의 swap_in 핸들러는 타입에 따라 자동으로 페이지를 초기화하고 주어진 AUX와 함께 INIT을 호출합니다. 페이지 구조체를 얻은 후, 해당 페이지를 프로세스의 보조 페이지 테이블에 삽입합니다. `vm.h`에 정의된 `VM_TYPE` 매크로를 사용하는 것이 편리할 수 있습니다.

페이지 폴트 핸들러는 호출 체인을 따라 진행되어, 최종적으로 `swap_in`을 호출할 때 `uninit_initialize`에 도달합니다. 아래는 `uninit_initialize`의 전체 구현을 제공합니다. 그러나 디자인에 따라 `uninit_initialize`를 수정해야 할 수도 있습니다.

```c
static bool uninit_initialize (struct page *page, void *kva);
```

첫 번째 페이지 폴트 시 페이지를 초기화합니다. 템플릿 코드는 먼저 vm_initializer와 aux를 가져와서 해당 페이지 초기화기를 함수 포인터를 통해 호출합니다. 디자인에 따라 함수를 수정해야 할 수도 있습니다.

당신의 요구에 맞게 `vm/anon.c` 파일에서 `vm_anon_init`과 `anon_initializer`를 수정할 수 있습니다.

```c
void vm_anon_init (void);
```

익명 페이지 하위 시스템을 위한 초기화입니다. 이 함수에서는 익명 페이지와 관련된 모든 설정을 할 수 있습니다.

```c
bool anon_initializer (struct page *page,enum vm_type type, void *kva);
```

이 함수는 익명 페이지 (즉, `VM_ANON`)의 초기화 함수로 사용됩니다. 먼저 `page->operations`에서 익명 페이지에 대한 핸들러를 설정합니다. 현재는 비어 있는 구조체인 `anon_page`에서 일부 정보를 업데이트해야 할 수도 있습니다.

`userprog/process.c`에 `load_segment` 및 `lazy_load_segment`를 구현해주세요. 실행 파일로부터 세그먼트 로딩을 구현해야 합니다. 이러한 모든 페이지는 게으르게 로드되어야 하며, 즉, 커널이 해당 페이지에 대한 페이지 폴트를 가로챌 때만 로드되어야 합니다.

`userprog/process.c`의 `load_segment` 함수에 있는 루프의 핵심을 수정해야 합니다. 루프의 각 반복마다 `vm_alloc_page_with_initializer`를 호출하여 보류 중인 페이지 객체를 생성합니다. 페이지 폴트가 발생할 때 실제로 파일에서 세그먼트를 로드합니다.

```c
static bool load_segment (struct file *file, off_t ofs, uint8_t *upage, uint32_t read_bytes, uint32_t zero_bytes, bool writable);
```

현재 코드는 파일에서 읽어야 할 바이트 수와 메인 루프에서 0으로 채울 바이트 수를 계산합니다. 그런 다음 `vm_alloc_page_with_initializer`를 호출하여 보류 중인 객체를 생성합니다. `vm_alloc_page_with_initializer`에 제공할 `aux` 인수로 `aux` 값을 설정해야 합니다. 이진 파일의 로딩에 필요한 정보를 포함하는 구조체를 만들 수도 있습니다.

```c
static bool lazy_load_segment (struct page *page, void *aux);
```

`load_segment`에서 `vm_alloc_page_with_initializer`의 네 번째 인자로 `lazy_load_segment`가 제공되는 것을 알 수 있습니다. 이 함수는 실행 파일의 페이지를 초기화하는 함수로서 페이지 폴트가 발생할 때 호출됩니다. 이 함수는 페이지 구조체와 aux를 인수로 받습니다. aux는 `load_segment`에서 설정한 정보입니다. 이 정보를 사용하여 세그먼트를 읽어들일 파일을 찾고, 최종적으로 세그먼트를 메모리에 읽어들여야 합니다.

`userprog/process.c` 의 `setup_stack` 함수를 수정하여 새로운 메모리 관리 시스템에 스택 할당을 맞추어야 합니다. 첫 번째 스택 페이지는 게으르게 할당될 필요가 없습니다. 명령줄 인수와 함께 로드 시에 할당하고 초기화할 수 있으며, 이를 폴트가 발생하기를 기다릴 필요가 없습니다. 스택을 식별하는 방법을 제공해야 할 수도 있습니다. `vm/vm.h`의 `vm_type`의 보조 마커 (예: `VM_MARKER_0`)를 사용하여 페이지를 표시할 수 있습니다.

마지막으로 `vm_try_handle_fault` 함수를 수정하여 보충 페이지 테이블을 참조하여 잘못된 주소에 해당하는 페이지 구조체를 해결합니다. 이를 위해 `spt_find_page`를 사용합니다.

요구 사항을 모두 구현한 후에는 fork를 제외한 프로젝트 2의 모든 테스트를 통과해야 합니다.

### ****Supplemental Page Table - Revisit****

이제 우리는 프로세스를 생성하거나 파괴할 때 필요한 복사 및 정리 작업을 지원하기 위해 보충 페이지 테이블 인터페이스를 재방문합니다. 세부 내용은 아래에 설명되어 있습니다. 이 시점에서 보충 페이지 테이블을 다시 방문하는 이유는 위에서 구현한 일부 초기화 함수를 사용하고자 할 수 있기 때문입니다.

**`supplemental_page_table_copy`** 와 **`vm/vm.c`** 안에 **`supplemental_page_table_kill`** 를 구현한다.

```c
bool supplemental_page_table_copy (struct supplemental_page_table *dst,
    struct supplemental_page_table *src);
```

src의 보충 페이지 테이블을 dst로 복사합니다. 이 작업은 자식 프로세스가 부모의 실행 컨텍스트를 상속해야 할 때 사용됩니다(즉, fork() 호출 시). src의 보충 페이지 테이블의 각 페이지를 반복하여 dst의 보충 페이지 테이블에 해당 항목을 정확히 복사합니다. 즉시 초기화되는 uninit 페이지를 할당해야합니다.

```c
void supplemental_page_table_kill (struct supplemental_page_table *spt);
```

보충 페이지 테이블이 보유하고 있던 모든 리소스를 해제합니다. 이 함수는 프로세스가 종료될 때 호출됩니다 (userprog/process.c의 process_exit() 함수). 페이지 항목을 반복하여 테이블 내의 페이지에 대해 destroy(page)를 호출해야합니다. 이 함수에서는 실제 페이지 테이블 (pml4)과 물리 메모리 (palloc으로 할당된 메모리)에 대해 걱정할 필요가 없습니다. 보충 페이지 테이블이 정리된 후 호출자가 이들을 정리합니다.

### ****Page Cleanup****

 **`vm/uninit.c`** 안에 **`uninit_destroy`** 그리고 `**vm/anon.c**` 안에 **`anon_destroy`** 를 구현한다.

이 함수는 초기화되지 않은 페이지에 대한 해제 작업을 처리합니다. 초기화되지 않은 페이지가 다른 페이지 객체로 변환되더라도 프로세스 종료 시에는 여전히 초기화되지 않은 페이지가 남을 수 있습니다.

```c
static void uninit_destroy (struct page *page);
```

page 구조체가 보유한 자원을 해제합니다. 페이지의 vm 유형을 확인하고 이에 따라 처리하는 것이 좋습니다.

현재는 익명 페이지만 처리할 수 있습니다. 나중에 파일 기반 페이지를 정리하기 위해 이 함수를 다시 살펴볼 것입니다.

```c
static void anon_destroy (struct page *page);
```

익명 페이지가 보유한 자원을 해제합니다. 페이지 구조체를 명시적으로 해제할 필요는 없으며, 호출자가 이를 처리해야 합니다.

**이제 프로젝트 2의 모든 테스트가 통과해야 합니다.**

---

## Memory Allocation

pintos는 두 개의 메모리 할당기를 포함하고 있다. 하나는 페이지 단위로 메모리를 할당하고, 다른 하나는 원하는 크기의 블록을 할당할 수 있는 메모리 할당기이다. (palloc과 malloc)

### Page Allocator

`include/threads/palloc.h` 에 선언된 페이지 할당기는 페이지 단위로 메모리를 할당하는 기능을 가지고 있으며, 일반적으로 한 번에 한 페이지씩 메모리를 할당하는 데 사용된다. 그러나 필요에 따라 한 번에 여러 개의 연속된 페이지를 할당할 수도 있다.

페이지 할당기는 할당하는 물리 메모리를 커널 풀과 유저 풀이라고 불리는 두 개의 풀로 나눈다. 기본적으로 각 풀은 1MB 이상의 시스템 메모리의 절반을 할당받지만, ul 커널 커맨드 라인 옵션을 사용하여 분할을 변경할 수 있다. 유저 풀은 유저 프로세스에 대한 메모리 할당에 사용되어야 하며, 커널 풀은 다른 모든 할당에 사용되어야 한다. 이는 프로젝트 3부터 중요해진다. 그 전까지는 모든 할당은 커널 풀에서 이루어진다.

각 풀의 사용 상태는 비트맵으로 추적된다. 풀 내의 각각의 페이지에는 하나의 비트가 있다. n개의 페이지를 할당하는 요청은 비트맵을 n개의 연속된 false로 설정된 비트를 검사하여 해당 페이지가 사용 가능하다는 것을 나타내며, 그 비트를 true로 설정해서 사용중으로 표시한다.

페이지를 할당기는 단편화 문제에 영향을 받는다. 즉 n개 이상의 페이지가 비어 있어도 현재 사용 중인 페이지로 인해서 n개의 연속된 페이지를 할당할 수 없을 수도 있다. 극단적인 경우에는 풀의 절반 이상의 페이지가 비어 있더라도 2개의 연속된 페이지를 할당하는 것이 불가능할 수도 있다. 단일 페이지 요청은 단편화로 인한 문제가 발생하지 않기 때문에 괜찮지만, 연속된 여러 페이지를 요청하는 경우는 위같은 문제를 발생시키기 때문에 최대한 제한해야 한다.

인터럽트 컨텍스트(즉 인터럽트가 발생했을 경우)에서는 페이지를 할당할 수는 없지만, 해제할 수는 있다.

페이지가 해제될 때 (palloc_free_page) 해당 페이지의 모든 바이트는 0xcc 값으로 설정되어 초기화된다.

페이지 할당과 관련된 함수는 다음과 같다.

---

```c
void *palloc_get_page (enum palloc_flags flags)
void *palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
```

> 하나의 페이지를 얻어서 반환하거나, page_cnt 만큼의 연속된 페이지를 얻어서 반환한다. 페이지를 할당할 수 없는 경우 null 포인터를 반환한다.
> 
> 
> ***flags* 인자는 다음 플래그들의 조합일 수 있다**:
> 
> - `PAL_ASSERT`
>     
>     페이지를 할당할 수 없는 경우 커널을 패닉 상태로 전환. 이는 주로 커널 초기화 중에만 적절하다. 사용자 프로세스는 커널을 패닉 상태로 전환시키는 것이 허용되지 않아야 한다.
>     
> - `PAL_ZERO`
>     
>     할당된 페이지의 모든 바이트를 0으로 설정한 후 반환한다. 설정되지 않은 경우, 새롭게 할당된 페이지의 내용은 예측할 수 없다.
>     
> - `PAL_USER`
>     
>     사용자 풀에서 페이지를 얻는다. 설정되지 않은 경우, 페이지는 커널 풀에서 할당된다.
>     

---

```c
void palloc_free_page (void *page)
void palloc_free_multiple (void *pages, size_t page_cnt)
```

> 페이지를 하나 또는 연속된 페이지 개수만큼 해제한다. 해제할 페이지는 모두 palloc_get_pate() 또는 palloc_get_multiple()을 사용해서 얻은 페이지이여야 한다.
> 

---

### Block Allocator

## Hash Table

Pintos는 `lib/kernel/hash.c` 에 해시 테이블 자료 구조를 제공합니다. 이를 사용하기 위해서는 `#include <hash.h>` 와 같이 해당 헤더 파일인 `lib/kernel/hash.h` 를 포함해야 합니다. Pintos와 함께 제공되는 코드 중에서는 해시 테이블을 사용하는 부분이 없기 때문에, 사용자는 원하는 대로 해시 테이블을 사용하거나 수정하여 필요에 맞게 구현하거나 무시할 수 있습니다.

Project3의 대부분 구현에서는 페이지를 프레임에 매핑하기 위해 해시 테이블을 사용합니다. 또한, 해시 테이블을 다른 용도로 활용할 수도 있습니다.

### Data Types

해시 테이블은 구조체 hash로 표현됩니다.

---

```c
struct hash;
```

> 해시 테이블 전체를 나타냅니다. struct hash의 실제 멤버들은 "불투명"합니다. 즉, 해시 테이블을 사용하는 코드는 struct hash 멤버에 직접 접근하거나 접근할 필요가 없어야 합니다. 대신 해시 테이블 함수와 매크로를 사용하세요.
> 

해시 테이블은 `struct hash_elem` 타입의 엘리먼트에 대해서만 동작합니다.

---

```c
struct hash_elem;
```

> 해시 테이블에 포함시키려는 구조체에 struct hash_elem 멤버를 내장시키세요. struct hash_elem은 struct hash와 마찬가지로 불투명합니다. 실제로 해시 테이블 원소를 조작하는 모든 함수는 실제 원소 타입이 아니라 struct hash_elem에 대한 포인터를 인자로 받고 반환합니다.
> 

해시 테이블의 실제 원소를 기반으로 `struct hash_elem`을 얻거나 그 반대의 작업을 수행해야 할 때가 많습니다. 해시 테이블의 실제 원소가 주어졌을 때는 & 연산자를 사용하여 해당 원소의 `struct hash_elem`에 대한 포인터를 얻을 수 있습니다. 그 반대로 진행할 때는 `hash_entry()` 매크로를 사용하세요.

---

```c
#define hash_entry (elem, type, member) { /* Omit details */ }
```

> elem이 struct hash_elem에 대한 포인터인 구조체 내에 포함된 구조체의 포인터를 반환합니다. elem이 속한 구조체의 이름인 type과 elem이 가리키는 type 내의 멤버인 이름인 member를 제공해야 합니다.

예를 들어, h가 struct hash_elem * 타입의 변수이고 h_elem이라는 struct thread 멤버(타입은 struct hash_elem)를 가리키는 경우, hash_entry(h, struct thread, h_elem)은 h가 가리키는 struct thread의 주소를 반환합니다.
> 

각 해시 테이블 요소는 고유해야 하는, 즉 요소들 사이에서 식별 및 구분을 할 수 있는 데이터인 키(key)를 포함해야 합니다. (요소는 고유하지 않아도 되는 비-키 데이터를 포함할 수도 있습니다.) 해시 테이블에 요소가 있는 동안에는 키 데이터를 변경해서는 안 됩니다. 대신, 필요한 경우 요소를 해시 테이블에서 제거하고 키를 수정한 후에 요소를 다시 삽입해야 합니다.

각 해시 테이블마다 키(key)에 작용하는 두 가지 함수를 작성해야 합니다: 해시 함수(hash function)와 비교 함수(comparison function). 이러한 함수들은 다음의 원형(프로토타입)과 일치해야 합니다.

---

```c
typedef unsigned hash_hash_func (const struct hash_elem *e, void *aux);
```

> element의 데이터에 대한 해시 값을 unsigned int 범위 내의 어떤 값으로 반환합니다. 해시 값은 random해야 한다. 해시 값은 요소의 키 이외의 키가 아닌 데이터나 키 이외의 비-상수 데이터에 의존해서는 안 됩니다. Pintos는 해시 함수에 적합한 기반이 되는 다음 함수들을 제공합니다.
> 
- `unsigned hash_bytes (const void *buf, size t *size)`
    
    > element의 데이터에 대한 해시 값을 unsigned int 범위 내의 어떤 값으로 반환합니다.
    > 
- `unsigned hash_string (const char *s)`
    
    > 정수 i의 해시값을 반환한다.
    > 
- `unsigned hash_int (int i)`
    
    > 정수 i의 해시값을 반환한다.
    > 

만약 키가 적절한 유형의 단일 데이터인 경우, 해시 함수가 이러한 함수 중 하나의 출력을 직접 반환하는 것이 합리적입니다. 여러 개의 데이터 조각의 경우에는 '^' (배타적 논리합) 연산자를 사용하여 이러한 함수 호출의 출력을 조합할 수 있습니다. 마지막으로, 이러한 함수를 완전히 무시하고 처음부터 직접 해시 함수를 작성할 수도 있지만, 목표는 운영 체제 커널을 구축하는 것이므로 해시 함수를 설계하는 것이 목표는 아닙니다. aux에 대한 설명은 [해시 보조 데이터] 섹션을 참조하세요.

- `bool hash_less_func (const struct hash_elem *a, const struct hash_elem *b, void *aux)`
    
    > 요소 a와 b에 저장된 키를 비교합니다. a가 b보다 작으면 true를 반환하고, a가 b보다 크거나 같으면 false를 반환합니다. 두 요소가 동일하게 비교되는 경우, 해시 값도 동일해야 합니다.
    **`aux`**에 대한 설명은 [Hash Auxiliary Data] 섹션을 참조하십시오. 해시 및 비교 함수 예제는 [Hash Table Example] 섹션을 참조하십시오. 몇 가지 함수는 인자로 세 번째 종류의 함수에 대한 포인터를 받습니다.
    > 
- `void hash_action_func (struct hash_elem *element, void *aux)`
    
    > 호출자가 선택한 동작을 element에 대해 수행합니다. aux에 대한 설명은 [Hash Auxiliary Data] 섹션을 참조하십시오.
    > 

## * Virtual memory management

- **paging**
    
    가상 메모리를 고정된 크기의 page 단위로 나누어서(고정 분할 방식) 관리하는 기법.
    
    - **virtual page**
        - 가상 페이지는 모두 같은 크기를 가진다. → 페이지 크기는 하드웨어에 의해 정해지고 일반적으로 2의 제곱수를 사용한다.
        - 페이지 테이블을 이용해서 가상 메모리 주소에서 물리 메모리 주소로 매핑한다.
    - **physical frame**
        - 물리 메모리 공간을 페이지와 같은 사이즈로 나눈 것을 프레임이라고 한다.
        - 프레임 크기도 페이지 사이즈와 동일하게 하드웨어에 의해 정해진다.
    - **page table & supplementary page table**
        - 페이지 테이블은 가상 메모리 상의 페이지를 물리 메모리 상의 프레임으로 매핑시켜주는 정보를 담고 있는 테이블이며, 모든 프로세스는 페이지 테이블을 가진다.
        - 페이지 테이블은 메인 메모리에 저장된다.
        - Page Table Base Register(PTBR)가 페이지 테이블을 가리키고, Page Table Length Register(PTLR)가 페이지 테이블의 크기를 가리킨다. → 이러한 레지스터들의 내용은 PCB에 저장되어 있다.(+ Context Switching이 일어날 때 교체된다.)
        - supplementary page table
            - 페이지 테이블을 보완하는 역할을 수행하는 데이터 구조이다. 즉, 페이지 테이블에는 없는 추가적인 데이터를 저장한다. → 페이지 테이블의 제약사항 극복, 더 많은 정보 관리 가능
            - 일반적으로 **페이지 폴트 처리**와 **자원 해제**와 같은 목적으로 사용된다.
- **Memory Management Unit (MMU)**
    
    메모리 관리 장치의 약자, 가상 메모리와 물리 메모리 간의 주소 변환을 담당하는 하드웨어 장치이다. 일반적으로 페이지 테이블을 사용해서 가상 주소를 물리 주소로 매핑한다. 페이지 테이블은 가상 메모리 공간을 페이지로 분할하고, 각 페이지에 대한 매핑 정보를 저장한다. MMU는 이러한 페이지 테이블을 참조해서 가상 메모리 주소의 페이지 번호를 확인하고 해당 페이지 번호에 대한 물리 메모리의 프레임을 찾아내서 실제 메모리 위치로 변환한다.
    
- **Translation Lookaside Buffer (TLB)**
    
    주소 변환 캐시라고 불리는 TLB는 MMU와 함께 동작하며, 가상 메모리 주소를 물리 메모리 주소로 변환하는 과정에서의 성능을 향상시키기 위해 사용되는 캐시이다. 페이지 테이블은 메인 메모리에 저장되어 있기 때문에 접근 시간이 상대적으로 오래 걸릴 수 있는데, 이런 경우 매번 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환하는 것은 비효율적일 수 있다. 이러한 문제를 해결하기 위해서 TLB가 사용된다. MMU가 주소를 변환할 때 먼저 TLB를 검사하여 가상 메모리 주소의 매핑 정보를 찾아보고, 정보가 존재한다면 메모리에 접근하지 않고 해당 물리 메모리 주소를 반환한다. 이로써 주소 변환에 필요한 메모리 액세스 시간을 크게 단축시킬 수 있다.
    
    - 가장 최근에 사용된 가상 메모리 주소의 매핑 정보를 저장한다.
    - TLB miss - TLB에 찾는 매핑 정보가 없을 때 발생.

## * Page type

- **Uninitialized page**
    
    프로세스의 가상 메모리 공간에서 사용되는 페이지 중 초기화 되지 않은 데이터를 포함하고 있는 페이지를 말한다. 프로세스가 실행되는 동안 데이터 페이지나 스택 페이지에는 초기화된 값이 할당되어 있지만, 힙 페이지나 BSS(Bloack Started by Symbol) 영역에 해당하는 페이지는 초기화되지 않은 상태로 할당될 수 있다. 이러한 페이지에는 초기화되지 않은 데이터나 전역 변수들이 위치하게 된다. 미초기화 페이지는 해당 페이지에 접근할 때 초기화되지 않은 값이 존재할 수 있으므로 주의해야 한다. 프로세스가 미초기화 페이지를 사용할 때는 반드시 초기화 작업을 통해 적절한 값을 할당해야 정확하고 안정적인 동작을 보장할 수 있다.
    
    - **Lazy initialization**
        
        초기화되어야 할 값이 실제로 필요한 시점까지 지연되는 초기화 방식을 말한다. 이는 프로그램 실행 시 모든 데이터를 한 번에 초기화 하는 대신에 해당 데이터에 처음으로 접근하는 시점에서 초기화를 수행하는 것을 의미한다. 
        
        이는 대규모의 데이터나 복잡한 시스템에서 초기화에 많은 시간이 소요되는 경우에 유용한 기법이다. 주의해야 할 점은 초기화가 필요한 데이터에 접근하기 전에 초기화 작업이 꼭 수행되어야 하며, 그렇지 않을 시에는 잘못된 동작이 발생할 수 있다.
        
- **Anonymous page**
    
    익명 페이지는 가상 메모리 시스템에서 파일이나 스왑 공간에 연결되지 않은 메모리 페이지를 말한다. 이러한 페이지는 주로 프로세스의 스택, 힙, BSS 등과 같은 프로세스 메모리 공간에 할당되며, 디스크에 저장된 파일과 직접적인 연관성을 갖지 않는다.
    
    익명 페이지의 특징과 동작 방식은 다음과 같다.
    
    1. 파일과 연결되지 않음 : 익명 페이지는 디스크에 저장된 파일과 연결되지 않는다. 따라서 해당 페이지는 파일 시스템에서 읽어오는 것이 아니라, 프로세스 메모리 공간 내에서 동적으로 생성된다.
    2. 초기화되지 않음 : 익명 페이지는 일반적으로 파일에 저장된 데이터로 초기화 되지 않는다. 초기화 되지 않은 페이지는 0 또는 임의의 값으로 채워지며, 프로세스가 필요에 따라 해당 페이지에 데이터를 쓰는 것이 가능하다.
    3. 스택과 힙 할당 : 프로세스의 스택과 힙 영역은 익명 페이지를 사용하여 동적으로 메모리를 할당한다. 프로세스의 스택은 호출된 함수와 지역 변수를 저장하는데 사용되며, 힙은 동적으로 할당된 메모리를 관리하는데 사용된다.
    4. 페이지 교체 및 스왑 : 익명 페이지는 페이지 교체 정책에 따라 메모리가 관리된다. 메모리가 부족한 경우 페이지 교체 알고리즘에 따라 일부 익명 페이지가 메모리에서 스왑 영역으로 스왑아웃 될 수 있다. 이렇게 스왑된 페이지는 나중에 다시 필요할 때 스왑인 되어 메모리로 복구 된다.
    5. 메모리 보호 : 익명 페이지는 일반적으로 읽기-쓰기-실행 가능한 권한을 가지며, 프로세스가 해당 페이지에 엑세스할 수 있다. 그러나 필요에 따라 읽기 전용 권한으로 설정하여 프로세스가 페이지의 내용을 수정하지 못하도록 할 수도 있다.
    6. 메모리 공간 공유 : 여러 프로세스가 동일한 프로그램을 실행하는 경우, 익명 페이지를 공유하여 메모리 공간을 공유할 수 있다. 이를 통해 여러 프로세스가 동일한 페이지를 메모리에 로드하지 않고 메모리 사용량을 줄이고 성능을 향상시킬 수 있다.
    
    - **stack growth**
        
        프로그램이의 실행 도중 스택 영역이 확장되는 것을 의미한다. 즉, 스택의 크기를 동적으로 조정하여 프로세스가 필요로 하는 추가적인 스택 공간을 확보하는 과정이다. 
        
        1. 스택 상향 : 스택이 낮은 주소에서 높은 주소로 성장하는 방식에서 스택의 크기가 상단으로 확장됨
        2. 스택 하향 : 스택이 높은 주소에서 낮은 주소로 성장하는 방식에서 스택의 크기가 하단으로 확장됨.
- **file-backed page**
    
    가상 메모리에서 실제 데이터를 파일에 저장하고 필요할 때 해당 파일에서 데이터를 로드하는 페이지이다. 일반적으로 메모리 매핑을 통해 구현된다.
    
    메모리 매핑은 파일의 내용을 가상 메모리 공간에 직접 매핑해서 파일의 데이터에 접근할 수 있도록 한다. 이는 파일을 메모리에 올리는 데에 필요한 디스크 I/O 작업을 줄여준다. 
    
    - **mmap syscall**
        
        파일을 가상 메모리에 매핑하는 데 사용되는 시스템 콜. mmap을 통해 파일을 메모리에 매핑하면 해당 파일의 데이터를 현재 가상 메모리에서 직접 접근할 수 있다.
        
        즉, mmap 호출을 통해서 파일을 메모리에 매핑하면 File-backed page를 생성할 수 있다.
        

## * Swap in/out

스왑 인과 스왑 아웃은 주기억장치와 보조기억장치 간의 데이터 이동을 뜻한다. 

1. **Swap Out**
    
    주기억장치에 있는 페이지 중에서 더  이상 사용되지 않는 페이지를 선정하여 보조기억장치로 옮긴다. 이는 주기억장치의 여유 공간을 확보하거나 페이지 교체 정책에 따라 새로운 페이지를 올리기 위해서이다. 스왑 아웃된 페이지는 주기억장치에서 해제되고, 해당 페이지를 저장하기 위해 보조기억장치의 스왑 영역에 저장된다.
    
2. **Swap In**
    
    보조기억장치에서 주기억장치로 페이지(또는 프레임)를 되돌리는 작업을 뜻한다. 주기억장치에 필요한 페이지가 없는 경우에 해당 페이지를 보조기억장치의 스왑영역에서 다시 주기억장치로 가져온다.
    
- **page replacement policy**
    
    페이지 교체 정책은 주기억장치에서 스왑 아웃될 페이지를 선택하는 알고리즘을 뜻한다. 이를 통해 page fault를 최소화하고 성능과 공정성을 균형 있게 유지하고자 한다.
    
    1. **FIFO (First-In, First-Out)**:
        - FIFO 알고리즘은 가장 오래된 페이지를 스왑 아웃하는 방식
        - 주기억장치에 올라온 순서대로 페이지를 유지하고, 가장 먼저 주기억장치에 들어온 페이지를 스왑 아웃.
    2. **LRU (Least Recently Used)**:
        - LRU 알고리즘은 가장 오랫동안 참조되지 않은 페이지를 스왑 아웃하는 방식
        - 페이지의 최근 접근 기록을 유지하고, 가장 오랫동안 참조되지 않은 페이지를 스왑 아웃
    3. **LFU (Least Frequently Used)**:
        - LFU 알고리즘은 가장 적게 참조된 페이지를 스왑 아웃하는 방식
        - 페이지의 참조 횟수를 계산하고, 가장 적게 참조된 페이지를 스왑 아웃
    4. **MFU (Most Frequently Used)**:
        - MFU 알고리즘은 가장 많이 참조된 페이지를 스왑 아웃하는 방식
        - 페이지의 참조 횟수를 계산하고, 가장 많이 참조된 페이지를 스왑 아웃
    5. **Optimal**:
        - Optimal 알고리즘은 가장 최적의 페이지를 스왑 아웃하는 방식
        - 미래의 참조 패턴을 가정하고, 가장 오랫동안 사용되지 않을 페이지를 스왑 아웃
        - 이 알고리즘은 이론적으로 가장 좋은 성능을 제공하지만, 실제로는 구현이 어렵고 예측이 어려워 사용되기 힘듬
- **swap disk**
    
    스왑 디스크(Swap Disk)는 운영체제에서 가상 메모리 관리를 위해 사용되는 보조 저장 장치입니다. 주 기억장치(RAM)의 용량이 제한적일 때, 운영체제는 주기억장치에 올라가지 않은 페이지를 스왑 디스크에 저장하여 추가 공간을 확보한다. 스왑 디스크는 주 기억장치와 비교하여 용량이 크고, 비교적 느린 접근 속도를 가지는 특징이 있다.
    

# ✅ TEAM WIL

---

<aside>
💡 Pintos Project3 : Virtual Memory (team 8)

</aside>

## ‼️ 주요 학습 내용

### Virtual memory (in PintOS)

아래 그림을 통해 핀토스의 가상 메모리에 대해 이해해보자.

![vm](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-18_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.36.57.png)

vm

프로세스들은 독립된 가상 메모리 공간을 가진다. 그리고 가상 메모리 공간은 커널 영역과 유저 영역으로 나뉜다. (어차피 가상 메모리는 페이지 단위로 구성되어있기 때문에 각각을 커널 페이지, 유저 페이지라고 표현한다.)

두 영역의 경계는 `KERN_BASE` 라는 상수로 `vaddr.h` 에 선언되어 있으며, 그 값은 `0x8004000000`이다. 즉, 가상 메모리의 커널 페이지 영역은 `0x8004000000` 보다 높은 곳에 위치해있다. 이말인 즉슨 `0x8004000000`보다 낮은 곳이 가상 메모리의 유저 페이지 영역이 된다. (+ `USER_STACK` 상수는 유저 페이지 영역 중 스택 영역이 시작되는 주소이고, 스택은 아래 방향으로 커진다. (stack growth).)

가상 메모리가 왼쪽 그림처럼 생겼다고 하자.. 그럼 가상 메모리는 물리 메모리에 어떻게 매핑이 되어있을까? 핀토스는 가상 메모리의 커널 페이지 영역이 물리 메모리에 1대1로 매핑된다.(그림 상에서 오른쪽) 즉, **가상 메모리 영역의 커널 페이지 영역이 곧 물리 메모리인 것**이다. `KERN_BASE`가 물리 메모리 주소 0에 매핑된다. (핀토스는 단일 프로세스 운영 체제이기 때문에 가상 메모리의 커널 영역이 물리 메모리에 1대 1로 매핑되어도 문제가 되지 않는다. 현재 프로세스가 전체 시스템의 주인이 되어 메모리 및 리소스에 대한 독점적인 접근 권한을 가지기 때문. → 다중 프로세스 운영 체제에서는 가상 메모리 매핑과 관련된 별도의 관리 및 보호 매커니즘이 필요함.)

이제 핀토스에서 프로세스가 생성되었을 때, 가상 메모리와 물리 메모리가 어떻게 구성되어 있는지 알게 되었다. 이제 구성된 메모리를 어떻게 사용하는지에 대해 알아보자.

핀토스에서는 메모리를 할당받기 위한 2가지 할당기를 지원한다. 하나는 페이지 단위로 메모리를 할당받는 `palloc`이고, 나머지 하나는 원하는 크기만큼의 메모리를 할당받는 `malloc`이다. 

일단 `palloc`부터 살펴보자. `palloc.c`를 살펴보면 알 수 있듯이 `palloc_get_page`는 1개의 페이지를 할당받는 함수이고, `palloc_get_multiple` 은 여러개의 연속된 페이지를 할당받는 함수이다. 두 함수는 공통적으로 flag를 인자로 받는데 이를 이용해서 할당받을 메모리가 속한 영역(`PAL_USER`)과 초기화 여부(`PAL_ZERO`) 그리고 할당 시 오류가 발생하면 패닉 상태로 전환하는 지(`PAL_ASSERT`)의 대한 조건들을 추가로 전달해줄 수 있다. 

여기서 중요하다고 생각이 드는건 `PAL_USER` 다. 해당 flag를 전달해줄 경우엔 가상 메모리의 커널 페이지 영역(핀토스는 가상 메모리 구조에서 커널 페이지 영역이 곧 물리 메모리 영역이다.)에서 유저 풀에 해당하는 영역의 메모리를 할당받을 수 있다.  `PAL_USER`를 전달해주지 않는다면? 커널 페이지 영역의 커널 풀에 해당하는 영역의 메모리를 할당받을 수 있다.

유저 풀과 커널 풀에 대해 이해하기 위해서 유저 모드와 커널 모드에 대한 선행 지식이 필요하다. 프로세스가 유저모드로 실행되고 있을 때에는 가상 메모리의 유저 페이지 영역의 메모리에만 접근이 가능하고, 커널 모드에서는 커널 풀에 직접 접근하거나 커널 풀에서 메모리를 할당받을 수 있다. (핀토스의 가상 메모리에는 힙영역이 존재하지 않는다. 그럼 유저 모드에서 동적으로 메모리를 할당받지 못한다? → gpt에게 물어본 결과 맞단다.. 즉 핀토스는 커널 모드에서만 메모리를 할당 받을 수 있다.)

다음은 `malloc`이다 `malloc`은 인자로 전달된 사이즈 만큼의 메모리를 할당해준다. `malloc`는 처음엔 `desc` 배열(디스크럽터들의 배열)을 순회하면서 인자로 들어온 `size` 만큼의 적합한 블록을 찾아 해당 블록을 할당해준다. 하지만 적합한 크기의 블록이 없는 경우 즉, 디스크립터를 찾지 못한 경우, `size`가 너무 큰 것이기 때문에 페이지(`PGSIZE`) 단위로 메모리를 할당한다. 이를 위해 여기서 `palloc_get_multiple` 함수를 호출하여 페이지의 개수만큼 메모리를 할당해준다. (추가적으로 arena? 라는 변수가 존재하는 데 이에 관해서는 더 공부해봐야 할 것 같다.)

결론적으로 핀토스는 힙영역이 존재하지 않기 때문에 정적으로 할당된 메모리 영역만을 사용한다. 즉 핀토스는 프로세스에 필요한 모든 메모리를 미리 할당(프로그램이 로드 될 때)하여 사용하고, 이 작업은 프로세스가 실행될 때 `load()` →`load_segment()`를 통해서 일어난다. 

Project3의 첫번째 ~ 두번째 과제(Memory Menagement ~ Anonymous Page)에서는 페이지 테이블을 보충하는 spt를 만들어서 새로운 방식으로 페이지 폴트를 처리하고 페이지 별로 타입을 두어 실행하는 프로그램의 세그먼트 페이지들을 익명 페이지로 설정해놓고 lazy loading을 시켜주게끔 vm 로직을 새롭게 구현했다. 이 때 spt는 해시 테이블 자료 구조를 사용해서 구현했다. 

## ‼️ 특이점

- 64bit 컴퓨터 시스템에서의 4단계 페이징 방식
- pintos가 부팅될 때 페이징 초기화 → `init.c/paging_init` 을 살펴보자.
- pml4가 물리 메모리 주소에 할당되는 이유에 대해?
- spt를 해시 테이블로 만들고자 할 때?
    - spt에 테이블 필드를 넣어준다.
    - spt의 각 원소들 즉, spt_entry = page이다.
        - 기존에 사용해왔던 hash table 구조와는 다름. buckets → bucket → page
    - hash.h를 보고 해시 테이블을 조작하는 방식에 대해 파악해야 한다.
- lazy_load_segment() 함수는 읽은 파일의 페이지를 생성해서 물리 메모리 주소에 할당해주는 역할인데, 페이지 테이블의 엔트리를 가져와서 이상한 작업을 해주고 있었음.

## ‼️ Trouble shooting

### PANIC : todo 오류

****Anonymous Page****의 Setup Stack까지 구현하고 테스트를 하니 PANIC : todo가 떴다. 

![화면 캡처 2023-06-18 202935.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_202935.png)

todo는 vm_get_frame에서 유저풀에 빈 페이지 공간을 할당 수 없을 때 PANIC이 뜨게 설정을 해주었다. 그래서 printf(”a”)를 찍어보니 

![화면 캡처 2023-06-18 203705.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_203705.png)

이런 식으로 엄청 많은 a가 찍혀있었다.

그래서 `palloc_get_page`에서 계속 할당을 해주니 더 이상 할당을 할 수 없어서 PANIC이 뜬다고 생각해서 코드를 찾아보니 `pml4_set_page` 에서 PML4에 가상 주소와 물리 주소를 매핑하는데 여기서 새 페이지의 권한을 줄 수 있다.

여기서 FLASE를 줄 때는

![화면 캡처 2023-06-18 212753.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_212753.png)

page의 가상 주소가 모두 같은 값으로 나온다.

하지만 TRUE를 줄 때는

![화면 캡처 2023-06-18 212907.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_212907.png)

page의 가상 주소가 다른 값으로 나온다.

그래서 아마도 FALSE를 줄 때 page→va가 계속 같은 값이 나와서 PML4에 계속 같은 값을 매핑 시켜 줄려고 하면 page fault가 뜨고 다시 `vm_do_claim_page`에 들어가서 계속 무한루프가 발생하는 것 같다.

## ‼️ 회고
