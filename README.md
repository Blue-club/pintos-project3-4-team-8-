# 크래프톤 정글 Week 10

담당자: 성헌, 넌 천, Hyeok Chang <br>
마감일: 2023/06/26 <br>
상태: In progress <br>
설명: 크래프톤 정글 WEEK 10 에 진행한 학습과 과정에 대한 기록. <br>

# ✅ 키워드

---

<aside>
💡 Pintos Project3 : Virtual Memory

</aside>

## *Virtual memory management

- paging
    - virtual page
    - physical frame
    - page table & supplementary page table
- Memory Management Unit (MMU)
- Translation Lookaside Buffer (TLB)

## *Page type

- Uninitialized page
    - Lazy initialization
- Anonymous page
    - stack growth
- file-backed page
    - mmap syscall

## *Swap in/out

- page replacement policy
- swap disk

## *Copy on Write (COW)

# ✅ 요일 별 TODO

---

## 📆 23.06.12(월)

- [x]  팀 페이지 세팅
- [x]  git repositorty 만들기 (~ Project2까지 코드 병합)
- [x]  Project3 virtual memory 이론 학습
    - [x]  git book 번역

## 📆 23.06.13(화)

- [x]  Project3 virtual memory 이론 학습
    - [x]  git book 번역
- [x]  알고리즘 문제 풀이 (15:00 ~ 16:30)

## 📆 23.06.14(수)

- [x]  Project3 virtual memory 이론 학습
    - [x]  git book 번역 - instruction
    - [x]  키워드 학습
        - Virtual memory management
        - Page type
        - Swap in/out

## 📆 23.06.15(목)

- [x]  Project3 - Memory Management 과제 수행
    - [x]  supplemental page table 생성

## 📆 23.06.16(금)

- [x]  Project3 - Memory Management 과제 수행
    - Memory Management
    - Anonymous Page

## 📆 23.06.17(토)

- [x]  Project3 - Memory Management 과제 수행
    - Memory Management
    - Anonymous Page

## 📆 23.06.18(일)

- [x]  기존 pintos의 vm 관련 소스 정리
- [x]  anonymous page까지 구현 후 현재 vm 관련 소스 정리

## 📆 23.06.19(월)

- [x]  Project3
    - Memory Management 테스트 디버깅
    - Stack growth
        - git book 해석 & 정독

## 📆 23.06.20(화)

- [x]  Project3
    - Memory Management 테스트 디버깅
    - Stack growth

## 📆 23.06.21(수)

- [x]  Project3
    - Stack growth
        - 구현 완료 but 이해 부족.
    - Memory Mapped Files
        - git book 해석 & 정독

## 📆 23.06.22(목)

- [x]  Project3
    - Memory Mapped Files
        - mmap 수정
        - munmap 구현 - 미구현 (넘 어려움..)

## 📆 23.06.23(금)

- [x]  Project3
    - Memory Mapped Files
    - Swap In/Out
        - git book 해석 & 정독

## 📆 23.06.24(토)

- [x]  Project3
    - Memory Mapped Files
        - mmap
    - Swap In/Out (구현중)

## 📆 23.06.25(일)

- [x]  Project3
    - Swap In/Out
- [x]  정리
    - 주요 학습 내용
    - 특이점
    - 트러블 슈팅
    - 발표 자료 정리

# ✅ 과제

---

<aside>
💡 git book을 바탕으로 과제 진행.

</aside>

### Virtual memory (in PintOS)

아래 그림을 통해 핀토스의 가상 메모리에 대해 이해해보자.

![vm (spt를 제외한 나머지가 현재 핀토스의 vm구조 이다.)](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-18_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.36.57.png)

vm (spt를 제외한 나머지가 현재 핀토스의 vm구조 이다.)

프로세스들은 독립된 가상 메모리 공간을 가진다. 그리고 가상 메모리 공간은 커널 영역과 유저 영역으로 나뉜다. (어차피 가상 메모리는 페이지 단위로 구성되어있기 때문에 각각을 커널 페이지, 유저 페이지라고 표현한다.)

두 영역의 경계는 `KERN_BASE` 라는 상수로 `vaddr.h` 에 선언되어 있으며, 그 값은 `0x8004000000`이다. 즉, 가상 메모리의 커널 페이지 영역은 `0x8004000000` 보다 높은 곳에 위치해있다. 이말인 즉슨 `0x8004000000`보다 낮은 곳이 가상 메모리의 유저 페이지 영역이 된다. (`USER_STACK` 상수는 유저 페이지 영역 중 스택 영역이 시작되는 주소이고, 스택은 아래 방향으로 커진다.)

가상 메모리가 왼쪽 그림처럼 생겼다고 하자.. 그럼 가상 메모리는 물리 메모리에 어떻게 매핑이 되어있을까? 핀토스는 가상 메모리의 커널 페이지 영역이 물리 메모리에 1대1로 매핑된다.(그림 상에서 오른쪽) 즉, **가상 메모리 영역의 커널 페이지 영역이 곧 물리 메모리인 것**이다. `KERN_BASE`가 물리 메모리 주소 0에 매핑된다. (핀토스는 단일 프로세스 운영 체제이기 때문에 가상 메모리의 커널 영역이 물리 메모리에 1대 1로 매핑되어도 문제가 되지 않는다. 현재 프로세스가 전체 시스템의 주인이 되어 메모리 및 리소스에 대한 독점적인 접근 권한을 가지기 때문. → 다중 프로세스 운영 체제에서는 가상 메모리 매핑과 관련된 별도의 관리 및 보호 매커니즘이 필요함.)

이제 핀토스에서 프로세스가 생성이 되었을 때, 가상 메모리와 물리 메모리가 어떻게 구성되어 있는지 알게 되었다. 이제 구성된 메모리를 어떻게 사용하는 지에 대해 알아보자.

핀토스에서는 메모리를 할당받기 위한 2가지 할당기를 지원한다. 하나는 페이지 단위로 메모리를 할당받는 `palloc`이고, 나머지 하나는 원하는 크기만큼의 메모리를 할당받는 `malloc`이다. 

일단 `palloc`부터 살펴보자. `palloc.c`를 살펴보면 알 수 있듯이 `palloc_get_page`는 1개의 페이지를 할당받는 함수이고, `palloc_get_multiple` 은 여러개의 연속된 페이지를 할당받는 함수이다. 두 함수는 공통적으로 flag를 인자로 받는데 이를 이용해서 할당받을 메모리가 속한 영역(`PAL_USER`)과 초기화 여부(`PAL_ZERO`) 그리고 할당 시 오류가 발생하면 패닉 상태로 전환하는 지(`PAL_ASSERT`)의 대한 조건들을 추가로 전달해줄 수 있다. 

여기서 중요하다고 생각이 드는건 `PAL_USER` 다. 해당 flag를 전달해줄 경우엔 가상 메모리의 커널 페이지 영역(핀토스는 가상 메모리 구조에서 커널 페이지 영역이 곧 물리 메모리 영역이다.)에서 유저 풀에 해당하는 영역의 메모리를 할당받을 수 있다.  `PAL_USER`를 전달해주지 않는다면? 커널 페이지 영역의 커널 풀에 해당하는 영역의 메모리를 할당받을 수 있다.

유저 풀과 커널 풀에 대해 이해하기 위해서 유저 모드와 커널 모드에 대한 선행 지식이 필요하다. 프로세스가 유저모드로 실행되고 있을 때에는 가상 메모리의 유저 페이지 영역의 메모리에만 접근이 가능하고, 커널 모드에서는 커널 풀에 직접 접근하거나 커널 풀에서 메모리를 할당받을 수 있다. (핀토스의 가상 메모리에는 힙영역이 존재하지 않는다. 그럼 유저 모드에서 동적으로 메모리를 할당받지 못한다? → gpt에게 물어본 결과 맞단다.. 즉 핀토스는 커널 모드에서만 메모리를 할당 받을 수 있다.)

다음은 `malloc`이다 `malloc`은 인자로 전달된 사이즈 만큼의 메모리를 할당해준다. `malloc`는 처음엔 `desc` 배열(디스크럽터들의 배열)을 순회하면서 인자로 들어온 `size` 만큼의 적합한 블록을 찾아 해당 블록을 할당해준다. 하지만 적합한 크기의 블록이 없는 경우 즉, 디스크립터를 찾지 못한 경우, `size`가 너무 큰 것이기 때문에 페이지(`PGSIZE`) 단위로 메모리를 할당한다. 이를 위해 여기서 `palloc_get_multiple` 함수를 호출하여 페이지의 개수만큼 메모리를 할당해준다. (추가적으로 arena? 라는 변수가 존재하는 데 이에 관해서는 더 공부해봐야 할 것 같다.)

결론적으로 핀토스는 힙영역이 존재하지 않기 때문에 정적으로 할당된 메모리 영역만을 사용한다. 즉 핀토스는 프로세스에 필요한 모든 메모리를 미리 할당(프로그램이 로드 될 때)하여 사용하고, 이 작업은 프로세스가 실행될 때 `load()` →`load_segment()`를 통해서 일어난다. 

Project3의 첫번째 ~ 두번째 과제(Memory Menagement ~ Anonymous Page)에서는 페이지 테이블을 보충하는 spt를 만들어서 새로운 방식으로 페이지 폴트를 처리하고 페이지 별로 타입을 두어 실행하는 프로그램의 세그먼트 페이지들을 익명 페이지로 설정해놓고 lazy loading을 시켜주게끔 vm 로직을 새롭게 구현했다. 이 때 spt는 해시 테이블 자료 구조를 사용해서 구현했다. 

### Supplemental Page Table

![해시 테이블 구조](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/6E8BDEFA-D888-449D-89D3-9F45940A6BD3_1_102_o.jpeg)

해시 테이블 구조

위에서 언급한 대로 프로세스 마다의 `spt`를 구성하고, `spt`를 이용해서 페이지 폴트를 처리해주어야 한다. spt 테이블을 구현을 위한 자료구조를 선택해야 하므로 난 git book에서 권장하는 hash table을 사용하여 구현했다.(hash table 자료구조에 대한 함수들은 `lib/kernel/hash.c`에서 찾을 수 있다.)

해시 테이블의 구조는 위 그림과 같다. `bucket`들의 `list`가 존재하고 각각의 `bucket`에는 `page`가 담긴다. 해시 테이블에 페이지를 담아주기 위해서는 해싱 함수가 필요하고 이는 직접 구현해야 한다. 나는 내장되어있던 hash_byte를 이용해서 구현했다. 완성된 해싱 함수는 다음과 같다.

![hash_func() 구현](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.55.44.png)

hash_func() 구현

또한 각 엔트리를 비교하는 hash_less 함수 또한 직접 구현해야 한다. 이 함수는 아직 정확하게 어디서 사용하는지 모르겠다. 일단 구현한 코드는 다음과 같다.

![hash_less() 구현](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.58.12.png)

hash_less() 구현

단순히 엔트리들의 키 값을 비교해서 순서대로 정렬을 해주는 식으로 구현했다.

이제 page fault가 발생했을 때 우선적으로 spt에서 페이지를 찾을 수 있도록, 페이지가 생성되는 즉시 spt에 해당 페이지를 넣어주어야 한다.

새로운 vm 시스템에서 모든 페이지는 `vm_alloc_page_with_initializer()` 에서 생성되므로 내부에 현재 프로세스(= 스레드)에 새롭게 생성되는 페이지를 넣어주는 코드를 작성해주면 된다. 구현한 코드는 아래와 같다.

![hash_insert를 사용해서 spt에 새롭게 만들 페이지를 넣어주자.](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.01.16.png)

hash_insert를 사용해서 spt에 새롭게 만들 페이지를 넣어주자.

### Anonymous Page & Lazy loading

![spt를 이용한 virtual memory의 동작 방식](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.13.07.png)

spt를 이용한 virtual memory의 동작 방식

vm 로직을 구현하기 전 핀토스는 어떤 프로그램의 프로세스가 생성될 때, 해당 프로그램에 대한 페이지를 모두 읽어들인 후, 한번에 페이지를 할당해주고 있었다. `process.c` 의 `load_segment()` 를 보면 

![반복적으로 file을 읽어와 페이지를 할당해준다.](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.21.56.png)

반복적으로 file을 읽어와 페이지를 할당해준다.

반복적으로 `read_bytes`를 읽어서 커널 페이지(`kpage`)에 할당해주고, `install_page()`를 통해서 해당 페이지에 대한 오프셋을 페이지 테이블에 등록하고, 유저 페이지에 매핑해주고 있다. 결론적으로 `load_segment()`가 끝나면 해당 프로그램에 대한 모든 페이지가 물리 메모리에 올라가고, 가상 메모리에도 매핑된다고 볼 수 있다.

하지만 여기서 의문이 하나 생긴다. 쓸지 안쓸지도 모르는 페이지를 미리 물리 메모리에 올려놓을 필요가 있을까? 해당 페이지가 필요할 때 파일을 읽어오면 안되는 걸까? 이러한 의문을 해결하기 위한 방법이 lazy loading 기법이다. 즉 모든 페이지를 spt에 등록해두고 (읽을 파일의 위치와 크기에 대한 정보를 file_segment라는 구조체에 담아 page에 저장해두는 것이 필요하다.) 만약 page fault가 발생한다면? spt를 탐색해서 해당 페이지에 대한 정보를 찾고 정보를 바탕으로 물리 메모리에 올리는 것이다. 이렇게 하면 각 페이지가 필요할 때만 물리 메모리 상에 매핑될 수 있다. 

### New Virtual Memory with Fork()…

기존의 가상 메모리 시스템(? 미구현 상태) 하에서 `fork()` 시스템 콜을 호출한다면? 부모의 `pml4`를 그대로 자식에게 전달해주었다.

![스크린샷 2023-06-20 오후 12.41.10.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-20_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.41.10.png)

새로운 가상 메모리 시스템에서 우리는 프로세스마다의 supplemental page table을 추가하여 페이지들을 관리해주고 있으므로 `fork()`를 통해 자식 프로세스가 생성되었을 때 `spt` 또한 넘겨주어야 한다.

즉, 

`bool supplemental_page_table_copy (struct supplemental_page_table *dst, struct supplemental_page_table *src)` 함수를 구현해주면 된다. 이전에 우리는 spt를 해시 테이블이라는 자료 구조를 활용해서 구현했다. 이를 고려하여 `bucket` 안에 있는 모든 엔트리에 대한 페이지를 찾은 후에, 자식 프로세스에서도 동일한 페이지가 매핑될 수 있도록 해준다.

### Stack Growth

vm 로직을 구현하기 전에 유저 스택 영역은 `USER_STACK`부터 시작해서 최대 1 페이지만(stack bottom = `0x4747f000`) 할당되어 활용되었다. 즉, 프로그램이 사용하는 메모리 공간 중 스택 영역은 이 한 페이지만 사용이 가능했다.

이제 유저 스택 영역을 최대 `1MB`로 설정해놓고 page fault가 발생했을 때, 해당 주소가 유저 스택 영역 내의 주소일 경우 유저 스택 영역을 해당 주소까지 확장해주는 stack growth를 구현할 것이다.

우선 스택 영역이 최대 `1MB`라 했음으로 스택 영역의 최하단 주소를 알 수 있다. 또한 한 페이지가 `4KB`이기 때문에 스택 페이지는 최대 256개가 됨을 알 수 있고, 다음과 같이 스택의 최하위 주소를 구할 수 있다.

```c
void *stack_bottom = (void *) (((uint8_t *) USER_STACK) - (PGSIZE * STACK_MAX_PAGES));
```

그럼 이제 vm_try_handle_fault 함수 내에서 page fault가 발생한 주소에 대해 스택 영역에 해당하는 지 판단할 수 있게 되었다.

![vm_try_handle_fault()](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-21_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.18.56.png)

vm_try_handle_fault()

그리고 추가적으로 stack growth가 필요한 page fault인지를 분별해주기 위해 page fault가 발생한 주소가 `rsp - (1 << 3)` 인지 확인해주고 아니라면? `false`를 리턴해준다.

우선 page fault가 발생한 주소에 대해 spt에 해당 페이지 정보가 존재하는지 확인한다. 존재하지 않는다면(page == NULL) 해당 주소는 false를 리턴하여 page fault 오류를 발생시켜야한다. 하지만 NULL임과 동시에 해당 주소가 유저 스택 내의 영역에 포함된다면? 해당하는 주소까지 스택 영역을 늘려주는 작업을 해줘야 한다. 즉, `vm_stack_growth` 함수를 구현해야 한다.

일단 구현한 코드는 아래와 같다. 처음에  `rsp` 에 대해 잘못 이해하고 있었어서 함수의 동작 방식을 파악할 수 없는 괴상한 코드를 짰었다. (근데 테스트는 통과했다..?) 그래서 스택에 대한 이해를 바탕으로 다시 코드를 작성했다.

```c
static void
vm_stack_growth (void *addr UNUSED) {
	struct thread *curr = thread_current();
	void *page_addr = pg_round_down(addr);

	while(spt_find_page(&curr->spt, page_addr) == NULL){
		vm_alloc_page_with_initializer(VM_ANON | VM_MARKER_0, page_addr, true, NULL, NULL);
		vm_claim_page(page_addr);

		page_addr += PGSIZE;
	}
}
```

 스택은 아래로 커지기 때문에 page fault가 발생한 `addr`부터 위로 페이지를 쌓아주어야 한다. 전달받은 addr의 주소를 `pg_round_down()`을 사용해서 해당 주소가 속하는 페이지 단위의 주소로 설정해준다. 그 후에 위로 쌓아 나가야 할텐데… 여기서는 현재 스텍 영역의 최하단이 어디인지를 알아야하기 때문에 `spt`를 활용해준다.`pg_round_down(addr)` 부터 스택 페이지를 쌓아 올리다가 다음 페이지를 할당할 주소에 해당하는 페이지가 `spt`에 존재할 경우에 `stack growth`를 멈춰준다. 

`rsp`는 현재 스택 페이지 내에서 최상단에 즉, 다음 데이터가 들어갈 수 있는 주소를 가리키고 있다. `rsp`는 `PUSH`나 `POP`과 같은 어셈블 명령어를 통해서 `+- 8byte` 씩 이동하며, `sub` 와 같은 명령어를 통해 한번에 많은 범위를 이동할 수도 있다. 

간략하게 설명하자면…

1. user program이 실행되고, argument passing 작업을 마치고 나면 `rsp`는 현재 스택 페이지 내의 사용이 가능한 영역의 최상단을 가리키고 있을 것이다.
2. 이후 유저 프로그램이 스택 영역에 데이터를 `PUSH` 하기도 하고 `POP` 하기도 할 것이다. (push와 pop은 어셈블 코드이고 각각 -8byte, +8byte 씩 rsp를 움직인다. 이 때 중요한 것은 두 명령어는 일단 데이터를 rsp에서 이동한 주소에 적재한 뒤에 rsp를 갱신한다.)
3. stack growth가 필요한 page fault가 발생했다는 것은? 현재 할당되어있는 스택 페이지가 꽉 차있는 상태에서 `push` 명령어를 사용한 것이라는 것을 유추해볼 수 있다. 즉, `rsp - (1 <<3)`을 참조하려다가 page fault가 발생한 것.
4. 그러므로 stack growth가 필요한 page fault인 경우에는 `addr`은 무조건 `rsp - (1<<3)`일 것이고 이 때 `pg_round_down(addr)` 부터 현재 스택의 최하단까지 페이지를 만들어서 쌓아올리는 작업을 해주면 된다.

### Mmap 과 Munmap

![mmap과 munmap의 구현 순서](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/D343E7DD-F7FF-4361-B44B-C2BEA0B80FB0.jpeg)

mmap과 munmap의 구현 순서

`mmap` 과 `munmap` 시스템 콜은 각각 파일 or 장치를 가상 메모리에 매핑 or 해제해주는 역할을 한다. 

---

- `void *mmap (void *addr, size_t length, int writable, int fd, off_t offset)`
    
    > 이 함수는 `fd`로 지정된 파일(`open()` 시스템콜을 이용해서 할당받음.)에서 `offset`에 해당하는 물리 주소에서 시작해서 `length` 바이트 만큼을 가상 주소 `addr`로 대응 시킨다. 깃북에서 `addr`은 항상 페이지 단위로 정렬되어있어야 한다고 했으니, `addr`은 각 페이지의 시작 주소여야 유효하다고 할 수 있다. `writable`은 매핑된 가상 페이지에 대한 권한을 나타내며, 매핑된 영역의 시작 포인터를 반환한다. 에러가 발생하면 MAP_FAILED(-1)이 반환된다.
    > 

---

- `void munmap (void *addr)`
    
    > `mmap`으로 할당된 메모리 영역을 해제한다. `addr`은 `mmap` 함수에 의해 반환된 주소이어야 한다.
    > 

---

`mmap`과 `munmap` 시스템콜을 사용하는 목적은 다음과 같다. 

- 메모리 매핑 - `mmap` 함수는 파일이나 기타 리소스를 메모리에 매핑하여 프로세스의 가상 메모리 공간에 해당 파일 내용이나 리소스를 나타내는 매핑을 생성해준다. 이를 통해서 파일을 쉽게 읽고 쓸 수 있고, 파일을 메모리처럼 다룰 수 있게 된다. (추가로 익명 페이지로의 매핑을 통해 다른 프로세스와의 공유도 가능하다.)
- 공유 메모리 - `mmap` 함수를 사용해서 여러 프로세스에서 동시에 같은 파일을 매핑하여 해당 메모리 영역을 공유할 수 있다. 이는 프로세스 간 통신이나 병렬 처리 등에서 유용하게 사용될 수 있다. (변경 사항은 매핑된 모든 프로세스에 반영된다.)
- 파일 I/O의 최적화 - `mmap`을 사용하면 파일을 메모리에 매핑해서 직접 메모리에서 파일을 읽고 쓸수 있는데, 이는 곧 파일 I/O 작업의 간소화라고 할 수 있다. 특히  대용량 파일을 다룰 때 유용하다.

이 정도까지 공부한 후에 바로 `mmap`부터 구현을 시도했다. 과제의 가이드에서는 `mmap`을 이용해서 매핑된 페이지 또한 lazy하게 로드되어야 한다고 했지만, 처음엔 페이지를 할당해주는 것을 목표로 코드를 작성해나갔다. 

또한 가이드북을 통해 예외 처리를 상당히 많이 해주어야 한다는 것을 알 수 있었기 때문에 시스템콜 코드를 먼저 작성하면서 예외 처리부터 진행하기로 했다. 

첫 번째 예외는 ***“`fd`로 열린 파일의 길이가 0바이트인 경우 mmap 호출이 실패할 수 있습니다.”*** 였고, 이는 곧 `length` 인자가 0일 때를 나타내므로 쉽게 예외 처리를 할 수 있다.

두 번째 예외는 ***“`addr`이 0인 경우 실패해야 합니다.”***이고, 이 또한 `addr == 0` 이면 `return NULL`을 해주는 것으로 쉽게 처리할 수 있다.

세 번째 예외는 ***“만약 `addr`이 페이지 정렬되지 않았거나, 매핑된 페이지의 범위가 스택이나 실행 파일 로드 시 매핑된 페이지(스택이나 실행 가능한 시간에 매핑된 페이지를 포함)와 겹치는 경우, 이 함수는 실패해야 합니다.”*** 였는데, 이는 `pg_round_down()` 함수를 이용해서 `addr`이 페이지 정렬된 주소인지 확인해주고, `spt`를 이용해서 이미 매핑된 페이지가 있는지 걸러주는 방식으로 예외 처리를 해주었다.

마지막 예외는 “***fd가 0이나 1일 경우”***이고***,*** 각각 표준 입력과 표준 출력을 의미하므로 말그대로 조건문으로 예외 처리해주었다.

작성한 코드는 다음과 같다.

![mmap() 예외 처리](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.31.52.png)

mmap() 예외 처리

`mmap`의 실제 로직은 `do_mmap`에서 구현해주었다. `mmap`의 역할에 대해서 알고있는 대로 파일에서 데이터를 읽은 후에 가상 메모리를 할당해주는 것이기 때문에 length 만큼을 읽어서 새로운 페이지에 할당해주는 방식으로 코드를 작성했다. 물론 lazy load 방식이 아니기 때문에 페이지가 생성되면 바로 커널 페이지(물리 메모리)에 매핑된다.

![do_mmap 함수 (lazy load 방식 미적용)](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.36.15.png)

do_mmap 함수 (lazy load 방식 미적용)

위처럼 코드를 작성하고 `make check` 명령어를 입력해보면 `mmap`과 관련된 테스트 일부가 `pass` 되는 것을 확인할 수 있으나… 가이드에서 제시한 대로 lazy load 방식이 아니기 때문에 대부분의 테스트가 `fail` 된다. 이제 `mmap` 동작 방식에 대한 감을 잡았으니 `lazy load` 방식으로 다시 구현해보자.

결국 기존에 anonymous page 처럼 lazy load 하도록 코드를 짜되, **실제 읽은 바이트 수가 읽어야 할 바이트 수와 다를 수 있다는 점**을 인지하고 코드를 짜야했다. 그래서 기존 lazy load 함수를 가지고 와서 활용했고, 함수 내부에서 페이지의 타입에 따라 분류해주었다.

작성한 코드는 아래와 같다.

![do_mmap 함수 (lazy load)](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.56.16.png)

do_mmap 함수 (lazy load)

변경된 lazy_load 함수는 다음과 같다.

![변경된 lazy_load_segment 함수](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.58.37.png)

변경된 lazy_load_segment 함수

우선 do_mmap 함수를 살펴 보자. 결국 `lazy_load_segment` 함수를 해당 페이지 구조체에 등록해놓고 이를 이용해서 page fault가 발생했을 때, 물리 메모리에 매핑이 되는 방식이기 때문에 기존 `load_segment` 함수의 코드와 거의 동일하게 작성했다. (`VM_MARKER`에 대한 설명은 `munmap` 구현에 대해 작성할 때 하는 걸로..) **여기서 의문이 들었던 건 옆 조의 코드는 `file_reopen()`을 통해서 해당 파일이 닫히더라도 파일 정보를 가지고 있을 수 있도록 해줬어야 했는데 내 코드는 해당 라인이 없어도 테스트가 통과되는 이슈가 있었다.** 필요한 코드라 생각해서 일단 적용해두었다. 

변경된 `lazy_load_segment` 함수를 보면 내부에서 인자로 전달된 `VM_TYPE`에 따라 분기 처리가 됨을 확인할 수 있다. 익명 페이지 타입인 경우에는 무조건 파일이 존재할 수 밖에 없고, `page_read_bytes`가 정확하기 때문에 그만큼 읽지 못한다면 오류로 간주하고 함수는 실패하게 된다. 성공적으로 파일을 읽었을 때는 페이지의 나머지 부분을 0으로 채워준다.

반면에 파일 페이지 타입인 경우 `page_read_bytes`가 실제로 파일에서 읽은 바이트 수와 다를 수 있는 상황이 있기 때문에 `true_bytes`라는 변수에 실제로 읽어진 크기를 담고 이를 `page_read_bytes`와 비교한다. 그리고 더 작게 읽힘과 동시에 `true_bytes`가 0이고 `page_read_bytes`가 0이 아닌 경우 파일을 제대로 읽지 못한 것으로 간주하고 함수는 실패하고 그게 아니라면 페이지의 나머지 부분을 0으로 채워준다.

여기까지 구현하고 `make check` 명령어를 입력해보니 16개 `fail`… `mmap`만 사용하는 테스트 중 `fail` 되는 테스트가 있어서 수정할 부분이 있을 것 같지만..? `munmap`부터 구현해보고 생각하기로 했다.

`munmap()`에 전달되는 인자는 `mmap()`을 호출했을 때 반환된 매핑된 메모리의 시작 주소이다. 이 말은 곧 매핑된 페이지의 개수를 알 수 없고, lazy load 형태로 구현했기 때문에 페이지의 타입이 `VM_FILE` 일 수도 있고 `VM_UNINIT` 일 수도 있을 것이다. 

이러한 것들을 고려해서 `addr`부터 시작해서 어딘가에 있을 마지막 페이지에 도달할 때까지 매핑되어있는 페이지를 해제해주어야 하고, 만약 파일이 수정되었다면? 수정된 파일을 기존 파일에 덮어써줘야 한다. (추가적으로 현재 프로세스가 자식 프로세스일 경우도 생각을 해주어야 함.)

더티비트를 사용해서 페이지가 수정됐는지 아닌지를 알 수 있다. 정리해보자면..

1. 주어진 addr에 해당하는 페이지부터 `VM_MARKER_1`이 설정되어있는 페이지까지 높은 주소로 이동한다.
2. 파일이 수정되었다면? 파일을 새롭게 덮어씌워준다. (`VM_UNIT` 타입일 경우 로드가 되지 않았으므로 = 페이지가 변경되지 않았으므로 덮어쓸 필요가 없다.)
3. 페이지 타입에 맞게 매핑을 해제해주자. 

작성한 코드는 다음과 같다.

![munmap의 구현](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.03.16.png)

munmap의 구현

추가적인 예외처리를 모두 해주고 나면 mmap과 관련된 테스트는 모두 통과해야한다.(+ `lazy_file`)

`fork()`와 관련된 매핑 처리와 `writable` 관련 예외 처리에서 많은 시간을 소비했다. 생각하지 못했던 예외들이 많았다 예로 들자면…

- `fork()`로 생성된 자식 프로세스에서 `mmap()`으로 파일을 매핑하고, 파일을 수정한 후에 `munmap()`을 하지 않고 자식 프로세스가 종료된다면? 파일은 덮어써질까? (in `mmap-exit`) → 답은 Yes이다. 그렇기 때문에 페이지가 해제될 때 해당 페이지가 VM_FILE임과 동시에 더티비트가 설정되었다면? 해당 페이지는 덮어씌워주는 식으로 해결했다.
    
    ![action_func() 구현](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.40.05.png)
    
    action_func() 구현
    
- `vm_try_handle_fault()` 에 전달되는 `not_present` 인자를 고려하자.  해당 인자가 true이면 페이지가 존재하지 않는다는 뜻이고 false이면 존재는 하지만? 읽기 전용이라는 뜻이다. 그러므로 읽기 전용 페이지일 경우엔 물리 메모리에 매핑해줄 필요가 없다. (`vm_do_claim`을 해줄 필요 x)
    
    ![vm_try_handle_fault() 수정](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.42.41.png)
    
    vm_try_handle_fault() 수정
    

### Swap In / Swap Out

가상 메모리 시스템에서 물리 메모리 상의 페이지 프레임을 할당받고자 할 때, 물리 메모리 공간이 부족하다면? 물리 메모리 상에 존재하는 페이지 프레임 중 하나를 내려주고 새로운 페이지 프레임을 할당시켜주면 될 것이다. 이러한 동작을 페이지 교체 기법이라고 한다. 내린다는 의미는 보조 디스크의 `swap area`에 페이지 프레임을 백업하는 것을 의미한다. 후에 해당 페이지 프레임이 필요하다는 요청을 받게되면 `swap area`에서 다시 물리 메모리로 올라가게 된다. 두 동작을 나누어서 `swap-in`, `swap-out`이라고 한다.

![2FE6B2FE-68D3-4714-8216-22C39B5D38C4_1_105_c.jpeg](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/2FE6B2FE-68D3-4714-8216-22C39B5D38C4_1_105_c.jpeg)

![D4BF41C7-063D-4BDC-B954-F77A6BF3F5C6_1_105_c.jpeg](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/D4BF41C7-063D-4BDC-B954-F77A6BF3F5C6_1_105_c.jpeg)

pintos의 페이지 타입에는 두 가지 종류가 있었다. `VM_ANON`과 `VM_FILE`. 여기서 `VM_FILE`은 `swap-out`이 될 때 굳이 `swap-area`로 내려갈 필요가 없다. 파일은 이미 디스크에 존재하기 때문이다. 그렇기에 `VM_FILE`의 `swap-out`의 경우에는 파일을 `overwrite` 해주는 식으로 수행한다. (물론 더티 비트가 설정되어있을 때만 수정한다.) (이는 핀토스에서만?그런 것 같다. 원래는 스왑 영역에 내려가는듯..? )

`VM_ANON` 타입의 페이지 같은 경우 `swap-out`이 될 때 `swap area`로 백업을 해주어야 한다. pintos 내에서 보조 메모리를 추상화한 disk라는 것이 존재하며, 이를 이용해서 `swap area`에 접근한다.

우선 `vm_anon_init` 함수에서 disk를 초기화하는 코드를 작성해주자.

![vm_anon_init()](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.10.55.png)

vm_anon_init()

`disk_get()` 함수를 이용해서 주어진 크기 만큼의 `swap area`를 할당받는다. 그리고 `swap-out`되어 있는 페이지들을 관리해주기 위해 `swap_slots` 이라는 연결 리스트를 전역변수로 선언해주고, 초기화를 진행해준다.

disk는 sector 단위로 관리된다. 핀토스 내에서 `disk`의 한 sector는 `512byte` 로 설정 되어있다. 한 페이지 프레임은 `4096byte` 이기 때문에 8개의 sector가 필요하다. 이를 위해 할당받은 `swap_disk`의 사이즈를 `SECTOR_PER_PAGE`(= 8)로 나누어 준다. 그리고 swap_slots에 swap_size 만큼의 공간을 만들어 둔다. 여기서 구조체 `swap_anon`의 필드는 다음과 같다. `is_used` 라는 멤버 변수를 통해서 해당 sector가 사용되었는지 확인할 수 있고, `sector_index`를 통해서 해당 slot이 시작되는 sector의 인덱스를 알 수 있다.

![swap_anon 구조체 (page→anon→swap_anon)](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.24.57.png)

swap_anon 구조체 (page→anon→swap_anon)

다음으로 swap-out 함수를 작성해야한다. 일단 구현한 코드는 아래와 같다. 

![anon_swap_out()](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.29.12.png)

anon_swap_out()

페이지 교체 알고리즘에 따라 swap-out 될 페이지 프레임이 선택되서 인자로 넘어온다. 해당 페이지를 swap area에 백업하기 위한 작업을 해주어야 한다. 우선 `swap_slots`를 순회하면서 `is_used`가 false인 slot을 찾은 후에 해당 slot의 `sector_index`부터 `disk_write()`해준다. (8번 반복!) 후에 page frame을 없애주고, `pml4`에서도 해당 페이지에 대한 정보를 제거해준다.

swap-in의 완성 코드는 아래와 같다.

![swap_out()](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.51.43.png)

swap_out()

![스크린샷 2023-06-26 오후 12.17.02.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.17.02.png)

# ✅ 알고가야 할 개념

---

<aside>
💡 Pintos Project 3을 진행하면서 알게된 개념들과 더 공부해야할 주제들을 정리.

</aside>

## 📚 Git Book 번역

---

## Introduction

## P**roject3: Virtual Memory**

이제 핀토스에 조금 익숙해졌을 것이다. 핀토스는 동기화를 통해서 실행 가능한 스레드를 스케줄링 할 수 있으며, 여러 개의 사용자 프로그램들을 동시에 로드할 수 있다. 그러나 실행할 수 있는 프로그램의 수와 크기는 주 기억 장치 크기에 의해 제한된다. 이번 프로젝트 3에서 illusion of infinite memory 이라는 것을 이용해서 이러한 제한을 제거해보자.

(project 3는 project 2를 기반으로 진행되므로 project 2에서의 테스트 프로그램은 project 3에서도 작동해야 한다. 즉, project 3 작업을 시작하기 전에 프로젝트 2 제출물의 버그를 수정하는 데 신경을 써야 한다. 그렇게 하지 않을 경우 project 3에서도 동일한 버그를 야기할 것이다.)

## Background

### Source Files

프로젝트 3은 /vm 디렉토리에서 작업한다. DO NOT CHANGE로 표시된 템플릿은 절대 변경하지 말아야 하며, 수정할 각 템플릿 파일에 대한 일부 세부 정보는 제공된다.

- `include/vm/vm.h`, `vm/vm.c`
    
    가상 메모리에 대한 일반적인 인터페이스를 제공한다. 헤더 파일에서는 가상 메모리 시스템이 지원해야 하는 다른 vm_type(VM_UNINIT, VM_ANON, VM_FILE, VM_PAGE_CACHE)에 대한 정의와 설명을 볼 수 있다. 여기서 보조 페이지 테이블을 구현해야 한다.
    
- `include/vm/uninit.h`, `vm/uninit.c`
    
    초기화 되지 않은 페이지에 대한 함수들을 제공한다. 현재의 설계에서는 모든 페이지가 초기에 미초기화된 페이지로 설정되며, 이후 익명 페이지 또는 파일 지원 페이지로 변환된다.
    
- `include/vm/anon.h`, `vm/anon.c`
    
    익명 페이지에 대한 함수들을 제공한다. (vm_type = VM_ANON)
    
- `include/vm/file.h`, `vm/file.c` (vm_type = VM_FILE)
    
    파일을 지원하는 페이지에 대한 함수들을 제공한다.
    
- `include/vm/inspect.h`, `vm/inspect.c`
    
     이 파일들에는 평가를 위한 메모리 검사 함수들이 포함되어 있다. 이 파일은 변경해서는 안된다.
    

이 프로젝트에서 작성하는 대부분의 코드는 vm 디렉토리에 있는 파일과 이전 프로젝트에서 소개된 파일들이다. 처음 접하는 파일은 다음과 같다.

- `include/devices/block.h`, `devices/block.c`
    
    이 파일들에 있는 인터페이스들은 블록 장치를 섹터 단위로 읽고 쓰는 작업을 가능하게 한다. 이를 이용해서 스왑 파티션에 블록 장치로 접근할 수 있다. 즉 스왑 파티션에 데이터를 읽거나 쓸 수 있게 된다.
    

### Memory Terminology

우리는 메모리와 저장소에 대한 일부 용어들을 제시한 후에 프로젝트를 시작할 것이다. 이 용어들 중 일부는 프로젝트 2에서 많이 사용했던 것일 수도 있다.(see [Virtual Memory Layout](https://casys-kaist.github.io/pintos-kaist/project2/introduction.html)), 하지만 그 중 많은 부분은 새로운 내용이다.

### **Pages**

페이지는 메모리의 작은 단위로, 가상 메모리에서 4,096바이트 크기로 구성된 연속된 영역을 말한다. 프로그램이 메모리를 사용할 때 페이지 단위로 분할되어 할당된다. 페이지 크기는 일반적으로 하드웨어나 운영 체제에 의해 정의되며, 이는 작업을 수행하는 데 필요한 최소한의 메모리 단위이다. 

페이지는 페이지 정렬, 즉 페이지 크기로 나누어 떨어지는 가상 주소에서 시작해야 한다. 예를 들어, 페이지 크기가 4,096 바이트인 경우, 페이지는 4,096, 8,192, 12,288와 같이 4,096로 나누어 떨어지는 가상 주소에서 시작해야 한다. 페이지 크기로 나누어 떨어지지 않는 가상 주소에서 페이지를 시작하면 페이지 경계를 넘어서는 문제가 발생할 수 있다. (64비트 가상 주소의 마지막 12비트는 페이지 내에서의 오프셋을 나타냅니다. 이 오프셋은 페이지의 시작 위치부터 몇 바이트나 떨어져 있는지를 나타내는 값이다.)

상위 비트는 곧 소개될 페이지 테이블에서의 인덱스를 나타내는 데 사용된다. 64비트 시스템에서는 4단계 페이지 테이블을 사용하며, 이는 가상 주소를 다음과 같이 보이게 한다.

```c
63          48 47            39 38            30 29            21 20         12 11         0
+-------------+----------------+----------------+----------------+-------------+------------+
| Sign Extend |    Page-Map    | Page-Directory | Page-directory |  Page-Table |    Page    |
|             | Level-4 Offset |    Pointer     |     Offset     |   Offset    |   Offset   |
+-------------+----------------+----------------+----------------+-------------+------------+
              |                |                |                |             |            |
              +------- 9 ------+------- 9 ------+------- 9 ------+----- 9 -----+---- 12 ----+
                                          Virtual Address
```

각 프로세스는 자체적으로 독립적인 가상 페이지 집합을 갖는다. 사용자 페이지는 KERN_BASE (0x8004000000) 아래에 위치한 페이지들을 말한다. 즉 KERN_BASE 주소보다 작은 가상 주소 영역에 있는 페이지들은 해당 프로세스의 사용자 페이지로 사용된다. 이를 통해서 각 프로세스는 자신만의 가상 메모리 공간을 사용하게 된다.

한편, 커널 가상 페이지의 집합은 전역적이며, 어떤 스레드나 프로세스가 실행 중인지에 관계없이 항상 동일한 위치에 유지된다. (가상 메모리는 **사용자 페이지**와 **커널 페이지**로 나뉜다. 각각의 프로세스는 자체적인 사용자 페이지를 갖고 있으며, 이 페이지들은 해당 프로세스의 독립적인 가상 메모리 공간으로 사용된다. 반면에  이를 통해서 사용자와 커널 간에 메모리를 분리하고 보안을 강화할 수 있다.) **커널은 사용자 페이지와 커널 페이지에 모두 접근할 수 있지만, 사용자 프로세스는 자신의 사용자 페이지에만 접근할 수 있다.**

(Pintos는 가상 주소를 다루기 위한 여러 유용한 함수를 제공한다. 자세한 내용은 '가상 주소' 섹션을 참조하자.)

### **Frames**

프레임은 물리 메모리의 연속된 영역으로, 때때로 물리적 프레임 또는 페이지 프레임이라고도 불린다. 프레임의 크기는 페이지의 크기와 동일해야 하고, 물리 메모리에서 페이지 크기와 정렬에 맞춰 할당된다.

즉, 프레임을 물리 메모리에서의 페이지라고 생각하면 될 것 같다. 가상 메모리 시스템에서 페이지는 가상 주소 공간에서 사용되고, 해당 페이지는 물리 메모리에서 프레임에 매핑된다. 이를 통해서 가상 주소 공간의 페이지를 물리 메모리에 매핑하고, 프로세스는 이를 통해 메모리에 접근할 수 있게 된다.

따라서, 64비트 물리 메모리 주소는 프레임 번호와 프레임 오프셋으로 나눌 수 있다. 이를 표현해보자면 다음과 같다.

```c
                          12 11         0
    +-----------------------+-----------+
    |      Frame Number     |   Offset  |
    +-----------------------+-----------+
              Physical Address
```

 x86-64 아키텍처에서 물리 메모리 주소에 직접적으로 접근할 수 있는 방법은 없다. 핀토스는 이를 극복하기 위해서 **커널 가상 메모리를 물리 메모리에 직접 매핑한다.** 커널 가상 메모리의 첫 번째 페이지는 물리 메모리의 첫 번째 프레임에 매핑되고, 두 번째 페이지는 두 번째 프레임에 매핑되는 식으로 이루어진다. 따라서, 프레임은 커널 가상 메모리를 통해 접근할 수 있다.

(핀토스는 물리 메모리 주소와 커널 가상 주소 간의 변환을 위한 함수를 제공하고 있다. 이 또한 자세한 내용은 '가상 주소' 섹션을 참조하자.)

### **Page Tables**

**페이지 테이블이란? CPU가 가상 주소를 물리 주소로 변환하는 데 사용하는 데이터 구조**라고 할 수 있다. 즉, CPU는 가상 주소가 속한 페이지를 해당 페이지가 매핑된 프레임으로 변환하여 실제 물리 메모리 주소를 얻게 된다. 이러한 가상 주소와 물리 주소 간의 변환은 페이지 테이블을 통해 이루어진다. 페이지 테이블의 형식은 x86-64 아키텍처에 정의되어 있다.

`threads/mmu.c` 파일에 페이지 테이블 관리 코드를 제공한다. 이 코드들은 핀토스 시스템에서 페이지 테이블을 관리하고, 가상 주소를 물리 주소로 변환하는 데 사용된다. 

아래의 다이어그램은 페이지와 프레임 간의 관계를 보여준다. 왼쪽에 있는 가상 주소는 페이지 번호와 오프셋으로 구성되어 있으며, 페이지 테이블을 통해 페이지 번호가 프레임 번호로 변환된다. 이 프레임 번호와 오프셋이 결합되어 물리 주소를 얻게 된다 즉, 가상 주소를 통해서 페이지와 프레임 간의 매핑이 이루어지며, 이를 통해서 물리 메모리 주소를 얻을 수 있게 된다.

```c
                          +----------+
         .--------------->|Page Table|-----------.
        /                 +----------+            |
        |   12 11 0                               V  12 11 0
    +---------+----+                         +---------+----+
    | Page Nr | Ofs|                         |Frame Nr | Ofs|
    +---------+----+                         +---------+----+
     Virt Addr   |                            Phys Addr    ^
                  \_______________________________________/
```

### Swap Slots

스왑 슬롯이란? 스왑 파티션에 있는 페이지 크기의 디스크 공간 영역이다. 

프레임은 물리 메모리에 직접적으로 매핑되는 메모리 영역으로, 프레임의 크기와 정렬은 하드웨어 제약에 따라 결정된다. 이는 특정 하드웨어 아키텍처에서 정해진 메모리 관리 방식에 따라 프레임이 할당되고 사용되어야 함을 의미한다.

반면에 스왑 슬롯은 디스크의 스왑 파티션에 저장되는 영역이며, 스왑 슬롯의 배치에 대한 하드웨어 제약은 상대적으로 유연하다. 즉, 스왑 슬롯이 디스크에 저장될 때, 프레임에 비해 상대적으로 자유롭게 배치될 수 있다. 이는 스왑 슬롯의 크기와 정렬에 대한 제약이 프레임보다 더 유연하게 적용될 수 있음을 의미한다.

따라서, 스왑 슬록은 하드웨어적인 제약이 비교적 유연하게 적용될 수 있기 때문에 스왑 파티션의 디스크 공간을 효율적으로 관리하고, 스왑 공간의 사용을 최적화하는 데에 도움을 줄 수 있다.

### Resource Management Overview

우리는 다음과 같은 데이터 구조를 설계/구현해야 한다. 

**Supplemental page table**

- 페이지 테이블을 보완해서 페이지 폴트 처리를 가능하게 한다. 즉, 메모리 관리에서 페이지 폴트가 발생했을 때, 보충 페이지 테이블을 통해서 누락된 페이지를 식별하고 필요한 프레임을 할당하여 메모리에 로드하는 역할을 수행한다.

**Frame table**

- 물리적인 프레임의 eviction(대체) 정책을 효율적으로 구현하는 데 사용된다.
- 프레임 테이블은 메모리 관리에서 어떤 프레임을 대체할 것인지를 결정하는 데 필요한 정보를 담고 있다. 이를 통해서 대체 정책을 구현하고 메모리의 효율을 높인다.

**Swap table**

- 스왑 슬롯의 사용 상태를 추적하는데 사용된다.
- 스왑 슬롯은 디스크의 스왑 파티션에 저장되는 페이지와 프레임의 대응 관계를 유지하기 위해 사용된다. 스왑 테이블은 어떤 스왑 슬롯이 현재 사용 중인지 추적하여 관리한다.

위의 세가지 데이터 구조를 완전히 독립된 구조로 구현할 필요는 없으며, 관련된 리소스를 하나로 통합해서 사용하는 편이 편리할 수 있다. 예를 들어 관련된 정보를 담는 하나의 통합 데이터 구조를 설계하거나, 한 데이터 구조 내에서 서로 연관된 데이터 필드를 가지도록 설계하는 등의 접근 방식을 고려할 수 있다. 

각 위의 데이터 구조마다 각 요소가 **어떤 정보를 포함해야 하는지 결정**해야 한다. 즉, 각 데이터 구조가 어떤 데이터를 저장하고 조작해야 하는지 정의해야 한다는 것을 뜻한다. 또한 **데이터 구조의 범위를 결정**해야 한다. 데이터 구조가 로컬 범위(프로세스 단위)에만 적용이 되는지 아니면 글로벌 범위(전체 시스템)에 적용되는지를 결정하자. 그리고 마지막으로 해당 범위 내에서 필요한 **인스턴스의 개수를 결정**해야 한다. 즉, 데이터 구조를 몇 개의 인스턴스로 구성해야 하는지를 결정하자 (이는 해당 범위 내에서 동시에 필요한 독립적인 데이터 구조의 개수를 의미한다.)

따라서 데이터 구조의 설계와 구현 시에 각 요소의 정보, 범위 그리고 필요한 인스턴스의 개수를 결정해야 한다. 이는 데이터 구조의 목적과 사용되는 컨텍스트에 따라 결정된다.

설계를 단순화하기 위해 이러한 데이터 구조를 페이링 할 수 없는 메모리 (calloc이나 malloc으로 할당된 메모리)에 저장하자. 이렇게 함으로써 포인터 유효성을 보장할 수 있다.

(일반적으로 페이지화 되지 않는 메모리는 운영 체제의 가상 메모리 관리 시스템에 의해 페이지 스왑 아웃되지 않고 메모리에 상주하도록 지정된 메모리 영역이다. 이는 데이터 구조가 물리적인 메모리에 위치함을 의미하며, 페이지 폴트가 발생하지 않는다는 것을 의미한다. 따라서 포인터를 통해 서로 연결된 데이터 구조의 주소가 변경되지 않고 유지될 수 있다. )

### Choices of implementation (Performance perspective)

구현에 가능한 선택지로는 배열, 리스트, 비트맵, 해시 테이블이 있다. 배열은 종종 가장 간단한 접근 방식이지만, 구성 요소가 희소하게 분포된 배열은 메모리를 낭비한다. 리스트 또한 간단하지만 특정 위치를 찾기 위해 긴 리스트를 탐색하는 것은 시간을 낭비한다. 배열과 리스트 모두 크기를 조정할 수 있지만, 리스트는 가운데에 삽입 및 삭제를 더 효율적으로 지원한다.

`lib/kernel/bitmap.c`와 `include/lib/kernel/bitmap.h`에 비트맵 데이터 구조가 포함되어 있다. 비트맵은 각각이 true 또는 false가 될 수 있는 비트의 배열이다. 비트맵은 일련의 자원의 사용 상태를 추적하는 데 일반적으로 사용된다. 자원 n이 사용 중이면 비트맵의 n번째 비트는 `true`이다. 핀토스의 비트맵은 크기가 고정되어 있으나, 크기 조정을 지원하도록 구현을 확장할 수 있다.

Pintos에는 해시 테이블 데이터 구조도 포함되어 있다. 해시 테이블은 삽입과 삭제를 다양한 크기의 테이블에 대해 효율적으로 지원한다.

더 복잡한 데이터 구조는 성능이나 기타 이점을 가져올 수 있지만, 구현을 불필요하게 복잡하게 만들 수도 있다. 따라서, 디자인의 일부로 고급 데이터 구조 (예: 균형 이진 트리)를 구현하는 것을 권장하지 않는다.

 

## ****Managing the Supplemental Page Table****

Supplemental Page Table은 각 페이지에 대한 추가 데이터로 페이지 테이블을 보완한다. 이는 페이지 테이블의 형식 때문에 발생한 제약 때문이다. (이와 같은 데이터 구조는 페이지 테이블이라고도 불리우기 때문에 혼동을 줄이기 위해 보충적이라는 단어를 추가한다.)

Supplemental Page Table은 적어도 두 가지 목적으로 사용된다. 가장 중요한 목적은 페이지 폴트가 발생했을 때, 커널이 보충 페이지 테이블에서 해당하는 가상 페이지를 찾아 어떤 데이터가 있어야 하는지 확인하는 것이다. 두 번째 목적은 프로세스가 종료될 때 커널은 어떤 자원을 해제해야 하는지 결정하기 위해 Supplemental Page Table을 참조한다.

### ****Organization of Supplemental Page Table****

Supplemental Page Table의 구성은 사용자의 요구에 맞게 자유롭게 조직될 수 있으며, 기본적으로 **세그먼트** 또는 페이지를 기준으로 구성할 수 있다. 세그먼트는 연속된 페이지의 그룹으로 이해되며, 실행 가능한 파일이나 메모리 매핑된 파일과 같은 메모리 영역을 나타냅니다.

(선택적으로 Supplemental Page Table의 멤버를 추적하기 위해 페이지 테이블 자체를 사용할 수 있다. 이를 위해서 `threads/mmu.c`에 있는 Pintos 페이지 테이블 구현을 수정해야 한다. 이 접근 방식은 어려우므로 초보 학생들에게는 권장하지 않는다.)

### ****Handling page fault****

Supplemental Page Table의 가장 중요한 기능은 페이지 폴트 핸들러이다. 프로젝트 2에서는 페이지 폴트가 항상 커널이나 사용자 프로그램의 버그를 나타냈지만 프로젝트 3부터는 페이지 폴트가 페이지를 파일이나 스왑 슬롯에서 가져와야 함을 나타낼 수도 있다. 이러한 경우를 처리하기 위해 더 복잡한 페이지 폴트 핸들러를 구현해야 한다.

페이지 폴트 핸들러는 `userprog/exception.c` 파일에 있는 `page_fault()` 함수이고, `vm/vm.c` 파일에 있는 `vm_try_handle_fault()` 함수를 호출한다. 페이지 폴트 핸들러는 대략적으로 다음 작업을 수행해야 한다.

1. 페이지 폴트 핸들러는 Supplemental Page Table에서 폴트가 발생한 페이지를 찾은 다음, 해당 페이지에 들어갈 데이터를 Supplemental Page Table 항목을 사용하여 찾는다. 데이터는 파일 시스템이나 스왑 슬롯에 있을 수 있으며, 페이지가 읽기 전용인 경우 데이터는 모두 0인 페이지일 수도 있다. 공유(Copy-on-Write)가 구현된 경우 페이지의 데이터는 페이지 프레임에 이미 존재할 수 있지만 페이지 테이블에는 없을 수도 있다. 만약 보충 페이지 테이블이 사용자 프로세스가 접근하려는 주소에 데이터가 없거나 페이지가 커널 가상 메모리에 있거나 읽기 전용 페이지에 대한 쓰기 시도인 경우, 접근은 잘못된 것으로 간주된다. 잘못된 접근이 발생한 경우 프로세스는 종료되며, 모든 리소스가 해제된다.
2. 페이지를 저장할 프레임을 얻는다. 공유 기능을 구현한 경우, 필요한 데이터가 이미 프레임에 있는 경우 해당 프레임을 찾을 수 있어야 한다.
3. 데이터를 가져와서 프레임에 넣는다. 이를 위해 파일 시스템이나 스왑에서 읽거나 0으로 초기화하는 등의 작업을 수행한다. 공유 기능을 구현한 경우, 필요한 페이지가 이미 프레임에 있는 경우에는 이 단계에서 추가 작업이 필요하지 않다.
4. 페이지 폴트가 발생한 가상 주소에 대한 페이지 테이블 항목을 해당 물리 페이지로 연결한다. 이를 위해 `threads/mmu.c` 파일의 함수를 사용할 수 있다.

## Managing the Swap Table

스왑 테이블은 사용 중인 스왑 슬롯과 빈 스왑 슬롯을 추적하며, 페이지를 스왑 파티션으로 이동시키는 데 사용할 수 있는 빈 스왑 슬롯을 선택하는 기능을 제공해야 한다. 또한, 해당 페이지가 다시 읽혀질 때나 페이지가 스왑되었던 프로세스가 종료될 때 해당 스왑 슬롯을 해제할 수 있어야 한다.

`vm/build` 디렉토리에서 명령어 pintos-mkdisk swap.dsk --swap-size=n을 사용하여 swap.dsk라는 디스크를 생성합니다. 이 디스크에는 n-MB 크기의 스왑 파티션이 포함된다. 그 이후에 pintos를 실행할 때 swap.dsk가 자동으로 추가 디스크로 연결된다. 대신, --swap-size=n 옵션을 사용하여 pintos에 임시 n-MB 스왑 디스크를 사용하도록 설정할 수 있다. 이는 단일 실행에 대해서만 적용된다.

스왑 슬롯은 필요할 때만 할당되어야 하며, 프로세스 시작 시 실행 파일에서 데이터 페이지를 즉시 스왑에 쓰는 것은 좋지 않다. 특정 페이지를 저장하기 위해 스왑 슬롯을 예약해서는 안 되며, 스왑 슬롯의 내용이 프레임으로 다시 읽혀질 때 해당 스왑 슬롯을 해제해야 한다.

## ****Managing Memory Mapped Files****

파일 시스템은 일반적으로 읽기와 쓰기 시스템 호출을 통해 접근되지만, 두 번째 인터페이스로는 mmap 시스템 호출을 사용하여 파일을 가상 페이지로 매핑할 수 있다. 이후 프로그램은 파일 데이터에 직접 메모리 명령을 사용할 수 있게 된다. 예를 들어, 파일 'foo'가 0x1000 바이트(4 kB 또는 한 페이지)라고 가정하고, 'foo'가 주소 0x5000에서 시작하여 메모리에 매핑된다면, 0x5000부터 0x5fff까지의 메모리 접근은 'foo'의 해당 바이트에 접근하게 된다.

아래의 프로그램은 명령 줄에 지정된 파일을 열고, 해당 파일을 가상 주소 0x10000000에 매핑한다. 그런 다음 매핑된 데이터를 콘솔(fd 1)에 출력하고, 파일의 매핑을 해제한다.

```c
#include <stdio.h>
#include <syscall.h>

int main (int argc UNUSED, char *argv[]) {
  void *data = (void *) 0x10000000;                 /* Address at which to map. */
  int fd = open (argv[1]);                          /* Open file. */
  void *map = mmap (data, filesize (fd), 0, fd, 0); /* Map file. */

  write (1, data, filesize (fd));                   /* Write file to console. */
  munmap (map);                                     /* Unmap file (optional). */

  return 0;
}
```

우리가 구현한 코드는 메모리 맵 파일에 의해 사용되는 메모리를 추적할 수 있어야 하며, 매핑된 영역에서의 페이지 폴트를 올바르게 처리하고 매핑된 파일이 다른 세그먼트와 겹치지 않도록 보장해야 한다.

## Memory Management

가상 메모리 시스템을 지원하기 위해서 가상 메모리의 상의 페이지와 물리 메모리 상의 프레임을 효과적으로 관리해야 한다. 이는 사용 중인 메모리 영역이 어떤 목적으로 누구에 의해 사용되는지 등을 추적해야 한다는 것을 의미한다. 

먼저 supplemental page table을 다루고 그 다음으로 물리 메모리 상의 프레임을 다룰 것이다. 이해를 돕기 위해 가상 메모리에서는 페이지라는 용어를 사용하고, 물리 메모리에서는 프레임이라는 용어를 사용한다.

## Page Structure and Operations

### Struct page

`include/vm/vm.h`에 정의된 페이지는 가상 메모리에서 페이지를 나타내는 구조체다. 이 구조체는 페이지에 대한 모든 필요한 데이터를 저장한다. 현재는 다음과 같이 구조체가 정의되어 있다.

```c
struct page {
  const struct page_operations *operations;
  void *va;              /* Address in terms of user space */
  struct frame *frame;   /* Back reference for frame */

  union {
    struct uninit_page uninit;
    struct anon_page anon;
    struct file_page file;
#ifdef EFILESYS
    struct page_cache page_cache;
#endif
  };
};
```

이 구조체는 Page Operations(아래 참조)을 가지고 있으며, 가상 주소와 물리적 프레임도 가지고 있습니다. 또한, 이 구조체에는 union 필드가 있습니다. union은 메모리 영역에 다른 유형의 데이터를 저장할 수 있는 특수한 데이터 형식입니다. union에는 여러 개의 멤버가 있지만, 한 번에 하나의 멤버만 값을 포함할 수 있습니다. 

이는 우리 시스템의 페이지가 uninit_page, anon_page, file_page, 또는 page_cache가 될 수 있다는 것을 의미합니다. 

예를 들어, 페이지가 익명 페이지인 경우 (Anonymous Page 참조), 페이지 구조체에는 struct anon_page anon 필드가 멤버로 포함됩니다. anon_page에는 익명 페이지에 대해 유지해야 하는 모든 필요한 정보가 포함됩니다.

### Page Operations

위에서 설명한 대로 `include/vm/vm.h`에서 정의된 대로, 페이지는 VM_UNINIT, VM_ANON, 또는 VM_FILE일 수 있습니다. 페이지에는 스왑 인, 스왑 아웃, 페이지 파괴와 같은 여러 동작이 필요합니다. 각 페이지 유형마다 이러한 동작에 대해 필요한 단계와 작업이 다릅니다. 

다시 말해, VM_ANON 페이지와 VM_FILE 페이지에 대해 서로 다른 파괴 함수를 호출해야 합니다. 각 함수에서 각 경우를 처리하기 위해 switch-case 구문을 사용하는 것이 한 가지 방법입니다.

이를 처리하기 위해 우리는 객체지향 프로그래밍의 '클래스 상속' 개념을 도입합니다. 실제로 C 프로그래밍 언어에서는 '클래스'나 '상속'이 없으므로, Linux와 같은 실제 운영 체제 코드에서와 비슷한 방식으로 함수 포인터를 사용하여 이러한 개념을 구현합니다.

함수 포인터는 메모리 내의 함수 또는 실행 가능한 코드를 가리키는 다른 포인터와 마찬가지로 포인터입니다. 함수 포인터는 런타임 값에 따라 특정 함수를 호출하여 실행하는 간단한 방법을 제공하기 때문에 유용합니다. 어떠한 확인도 필요하지 않습니다. 우리의 경우에는 코드 수준에서 destroy(page)를 호출하는 것만으로도 충분하며, 컴파일러는 올바른 함수 포인터를 호출하여 페이지 유형에 따라 적절한 destroy 루틴을 선택할 것입니다.

페이지 동작을 위한 구조체인 **`struct page_operations`**가 **`include/vm/vm.h`**에 정의되어 있습니다. 이 구조체를 함수 포인터가 3개 있는 함수 테이블로 생각해보세요.

```c
struct page_operations {
  bool (*swap_in) (struct page *, void *);
  bool (*swap_out) (struct page *);
  void (*destroy) (struct page *);
  enum vm_type type;
};
```

이제 **`page_operations`** 구조체를 어디에서 찾을 수 있는지 살펴봅시다. **`include/vm/vm.h`** 파일에서 **`struct page`**라는 **`page`** 구조체를 보면, **`operations`**라는 필드가 있는 것을 볼 수 있습니다. 이제 **`vm/file.c`**로 이동하면, **`page_operations`** 구조체인 **`file_ops`**의 선언을 볼 수 있습니다. 이는 파일을 기반으로 하는 페이지에 대한 함수 포인터 테이블입니다. 이 구조체의 **`destroy`** 필드는 **`file_backed_destroy`** 함수를 가리키고 있는데, 이 함수는 같은 파일에 정의되어 있는 페이지를 파괴하는 함수입니다.

함수 포인터 인터페이스를 통해 **`file_backed_destroy`**가 어떻게 호출되는지 이해해보겠습니다. 가정해보자면, **`vm/vm.c`**에서 **`vm_dealloc_page(page)`**가 호출되고, 이 **`page`**가 파일을 기반으로 한 페이지 (**`VM_FILE`**)인 경우입니다. 함수 내부에서 **`destroy(page)`**를 호출합니다. **`destroy(page)`**는 다음과 같은 형태의 매크로로 **`include/vm/vm.h`**에 정의되어 있습니다.

```c
#define destroy(page) if ((page)->operations->destroy) (page)->operations->destroy (page)
```

**`destroy`** 함수를 호출하면 실제로 **`(page)->operations->destroy(page)`**가 호출되며, 이는 페이지 구조체에서 검색된 destroy 함수입니다. 해당 페이지가 **`VM_FILE`** 페이지이므로, **`.destroy`** 필드는 **`file_backed_destroy`**를 가리킵니다. 결과적으로, 파일 기반 페이지에 대한 destroy 루틴이 수행됩니다.

## ****Implement Supplemental Page Table****

현재 시점에서, Pintos에는 가상 메모리의 물리 메모리 매핑을 관리하기 위한 페이지 테이블 (pml4)이 있습니다. 하지만, 이것만으로는 충분하지 않습니다. 이전 섹션에서 논의한 대로, 페이지 폴트와 리소스 관리를 처리하고, 각 페이지에 대한 추가 정보를 보유하기 위해 보충 페이지 테이블을 구현해야 합니다. 따라서, 우리는 프로젝트 3의 첫 번째 작업으로 보충 페이지 테이블에 대한 몇 가지 기본 기능을 구현하는 것을 제안합니다.

**Implement supplemental page table management functions in `vm/vm.c`.**

먼저 Pintos에서 보충 페이지 테이블을 어떻게 설계할지 결정해야 합니다. 자체적으로 보충 페이지 테이블을 설계한 후, 해당 설계에 따라 다음 세 가지 함수를 구현하십시오.

---

`void supplemental_page_table_init (struct supplemental_page_table *spt);`

> 보충 페이지 테이블을 초기화합니다. 보충 페이지 테이블에 사용할 데이터 구조를 선택할 수 있습니다. 이 함수는 새로운 프로세스가 시작될 때(`initd` 함수 내에서)와 프로세스가 포크될 때(`__do_fork` 함수 내에서) 호출됩니다.
> 

---

`struct page *spt_find_page (struct supplemental_page_table *spt, void *va);`

> 인자로 주어진 보충 페이지 테이블에서 `va`에 해당하는 `struct page`를 찾습니다. 실패할 경우 NULL을 반환합니다.
> 

---

`bool spt_insert_page (struct supplemental_page_table *spt, struct page *page);`

> 인자로 주어진 보충 페이지 테이블에 `struct page`를 삽입합니다. 이 함수는 주어진 보충 페이지 테이블에 가상 주소가 존재하지 않는지 확인해야 합니다.
> 

---

## Frame Management

이제부터 모든 페이지는 단순히 구성 시점의 메모리의 메타 데이터만을 담고 있는 것이 아닙니다. 따라서 물리 메모리를 관리하기 위해 다른 방식이 필요합니다. `include/vm/vm.h`에는 물리 메모리를 나타내는 `struct frame`이 존재합니다. 현재 이 구조체는 다음과 같이 정의되어 있습니다.

```c
/* The representation of "frame" */
struct frame {
  void *kva;
  struct page *page;
};
```

이 구조체는 `kva`라는 커널 가상 주소와 `page`라는 페이지 구조체 두 개의 필드만을 가지고 있습니다. 프레임 관리 인터페이스를 구현하는 과정에서 필요에 따라 멤버를 추가할 수 있습니다.

**Implement `vm_get_frame`, `vm_claim_page` and `vm_do_claim_page` in `vm/vm.c`.**

---

`static struct frame *vm_get_frame (void);`

> palloc_get_page를 호출하여 사용자 풀에서 새로운 물리 페이지를 얻습니다. 사용자 풀에서 페이지를 성공적으로 얻으면 프레임을 할당하고, 멤버를 초기화한 후에 반환합니다. vm_get_frame을 구현한 이후에는 모든 사용자 공간 페이지 (PALLOC_USER)를 이 함수를 통해 할당해야 합니다. 페이지 할당에 실패하는 경우에는 현재 스왑 아웃을 처리할 필요가 없습니다. 단지 해당 경우를 PANIC("todo")로 표시해주면 됩니다.
> 

---

`bool vm_do_claim_page (struct page *page);`

> Claims는 물리 프레임과 페이지를 할당하는 것을 의미합니다. 먼저 `vm_get_frame`을 호출하여 프레임을 얻습니다 (이 부분은 이미 템플릿에서 구현되어 있습니다). 그런 다음 MMU를 설정해야 합니다. 즉, 가상 주소와 물리 주소의 매핑을 페이지 테이블에 추가해야 합니다. 반환값은 작업이 성공했는지 여부를 나타내어야 합니다.
> 

---

`bool vm_claim_page (void *va);`

> 해당 가상 주소(va)에 페이지를 할당합니다. 먼저 페이지를 얻은 다음, 해당 페이지를 vm_do_claim_page 함수에 전달합니다.
> 

---

## ****Anonymous Page****

*이 프로젝트의 이 부분에서는 익명 페이지* 라는 비디스크 기반 이미지를 구현합니다 .

익명 매핑에는 백업 파일이나 장치가 없습니다. 파일 기반 페이지와 달리 명명된 파일 소스가 없기 때문에 익명입니다. 익명 페이지는 스택 및 힙과 같은 실행 파일에서 사용됩니다.

`include/vm/anon.h` 에는 익명 페이지를 설명하는 구조체인 **`anon_page`**가 있습니다. 현재는 비어 있지만 구현을 진행하면서 필요한 정보나 익명 페이지의 상태를 저장하는 멤버를 추가할 수 있습니다. 또한, `include/vm/page.h`에 있는 **`struct page`**를 살펴보세요. 이 구조체는 페이지의 일반적인 정보를 포함하고 있습니다. 익명 페이지의 경우, 해당 페이지 구조체에 **`struct anon_page anon`**이 포함되어 있습니다.

### ****Page Initialization with Lazy Loading****

**Lazy loading**은 **메모리 로딩을 필요한 시점까지 지연시키는 디자인**입니다. 페이지가 할당되어 있지만 해당 페이지에 대응하는 전용 물리 프레임은 없으며, 페이지의 실제 내용은 아직 로드되지 않은 상태입니다. **내용은 페이지 폴트에 의해 실제로 필요한 시점에만 로드됩니다.**

세 가지 종류의 페이지 유형이 있기 때문에 각 페이지에 대한 초기화 루틴이 다릅니다. 아래 섹션에서 다시 설명하겠지만, 여기에서는 페이지 초기화 흐름에 대한 수준높은 개요를 제공합니다. 먼저, 커널이 새 페이지 요청을 받으면 vm_alloc_page_with_initializer가 호출됩니다. 이 초기화 루틴은 페이지 구조체를 할당하고 페이지 유형에 따라 적절한 초기화 함수를 설정한 후 제어를 사용자 프로그램에 반환합니다. 사용자 프로그램이 실행되는 동안 어느 시점에서 페이지 폴트가 발생하면, 프로그램이 접근하려는 페이지가 아직 내용이 없는 경우입니다. 폴트 처리 절차 중에 uninit_initialize가 호출되고, 이전에 설정한 초기화 함수가 호출됩니다. 익명 페이지의 경우는 anon_initializer가 사용되고, 파일을 기반으로 한 페이지의 경우 file_backed_initializer가 사용됩니다.

한 페이지는 초기화(initialize) → (페이지 폴트(page_fault) → 게으른 로딩(lazy-load) → 스왑인(swap-in) → 스왑아웃(swap-out) → ...) → 소멸(destroy)의 라이프 사이클을 가질 수 있습니다. 라이프 사이클의 각 전환마다 페이지 유형(또는 VM_TYPE)에 따라 필요한 절차가 다르며, 앞선 문단은 초기화에 대한 예시였습니다. 이 프로젝트에서는 각 페이지 유형에 대해 이러한 전환 과정을 구현하게 됩니다.

### ****Lazy Loading for Executable****

Lazy loading은 메모리 로딩을 필요한 시점까지 지연시키는 디자인입니다. 페이지가 할당되어 있지만 해당 페이지에 대응하는 전용 물리 프레임은 없으며, 페이지의 실제 내용은 아직 로드되지 않은 상태입니다. 내용은 페이지 폴트에 의해 실제로 필요한 시점에만 로드됩니다.

Lazy loading을 지원하기 위해, `include/vm/vm.h`에 `VM_UNINIT`라는 페이지 유형을 도입합니다. **모든 페이지는 초기에 `VM_UNINIT` 페이지로 생성됩니다.** 또한, `include/vm/uninit.h`에는 초기화되지 않은 페이지를 위한 구조체 `uninit_page`가 제공됩니다. 초기화되지 않은 페이지를 생성, 초기화 및 파괴하기 위한 함수는 `include/vm/uninit.c`에 있습니다. 나중에 이러한 함수들을 완성해야 합니다.

페이지 폴트가 발생하면 페이지 폴트 핸들러인 `userprog/exception.c`의 `page_fault`가 `vm/vm.c`의 `vm_try_handle_fault`로 제어를 전달합니다. 이 함수는 먼저 유효한 페이지 폴트인지 확인합니다. 여기서 유효한 페이지 폴트란 잘못된 접근을 의미합니다. 만약 잘못된 페이지 폴트라면 페이지에 어떤 내용을 로드하고 사용자 프로그램으로 제어를 반환합니다.

부정확한 페이지 폴트에는 세 가지 경우가 있습니다: 레이지 로딩된 페이지, 스왑된 페이지, 그리고 쓰기 보호된 페이지 (Copy-on-Write (Exrtra) 참조). 현재는 첫 번째 경우인 레이지 로딩된 페이지만 고려합니다. lazy loading을 위한 페이지 폴트라면, 커널은 이전에 설정한 초기화 함수 중 하나인 `vm_alloc_page_with_initializer`를 호출하여 세그먼트를 lazy loading합니다. 이에 대한 구현은 `userprog/process.c`에서 `lazy_load_segment`를 완성해야 합니다.

`vm_alloc_page_with_initializer()` 함수를 구현해야 합니다. 전달된 `vm_type`에 따라 적절한 초기화 함수를 가져와 `uninit_new`를 호출해야 합니다.

```c
bool vm_alloc_page_with_initializer (enum vm_type type, void *va,
        bool writable, vm_initializer *init, void *aux);
```

주어진 타입으로 초기화되지 않은 페이지를 생성합니다. uninit 페이지의 swap_in 핸들러는 타입에 따라 자동으로 페이지를 초기화하고 주어진 AUX와 함께 INIT을 호출합니다. 페이지 구조체를 얻은 후, 해당 페이지를 프로세스의 보조 페이지 테이블에 삽입합니다. `vm.h`에 정의된 `VM_TYPE` 매크로를 사용하는 것이 편리할 수 있습니다.

페이지 폴트 핸들러는 호출 체인을 따라 진행되어, 최종적으로 `swap_in`을 호출할 때 `uninit_initialize`에 도달합니다. 아래는 `uninit_initialize`의 전체 구현을 제공합니다. 그러나 디자인에 따라 `uninit_initialize`를 수정해야 할 수도 있습니다.

```c
static bool uninit_initialize (struct page *page, void *kva);
```

첫 번째 페이지 폴트 시 페이지를 초기화합니다. 템플릿 코드는 먼저 vm_initializer와 aux를 가져와서 해당 페이지 초기화기를 함수 포인터를 통해 호출합니다. 디자인에 따라 함수를 수정해야 할 수도 있습니다.

당신의 요구에 맞게 `vm/anon.c` 파일에서 `vm_anon_init`과 `anon_initializer`를 수정할 수 있습니다.

```c
void vm_anon_init (void);
```

익명 페이지 하위 시스템을 위한 초기화입니다. 이 함수에서는 익명 페이지와 관련된 모든 설정을 할 수 있습니다.

```c
bool anon_initializer (struct page *page,enum vm_type type, void *kva);
```

이 함수는 익명 페이지 (즉, `VM_ANON`)의 초기화 함수로 사용됩니다. 먼저 `page->operations`에서 익명 페이지에 대한 핸들러를 설정합니다. 현재는 비어 있는 구조체인 `anon_page`에서 일부 정보를 업데이트해야 할 수도 있습니다.

`userprog/process.c`에 `load_segment` 및 `lazy_load_segment`를 구현해주세요. 실행 파일로부터 세그먼트 로딩을 구현해야 합니다. 이러한 모든 페이지는 게으르게 로드되어야 하며, 즉, 커널이 해당 페이지에 대한 페이지 폴트를 가로챌 때만 로드되어야 합니다.

`userprog/process.c`의 `load_segment` 함수에 있는 루프의 핵심을 수정해야 합니다. 루프의 각 반복마다 `vm_alloc_page_with_initializer`를 호출하여 보류 중인 페이지 객체를 생성합니다. 페이지 폴트가 발생할 때 실제로 파일에서 세그먼트를 로드합니다.

```c
static bool load_segment (struct file *file, off_t ofs, uint8_t *upage, uint32_t read_bytes, uint32_t zero_bytes, bool writable);
```

현재 코드는 파일에서 읽어야 할 바이트 수와 메인 루프에서 0으로 채울 바이트 수를 계산합니다. 그런 다음 `vm_alloc_page_with_initializer`를 호출하여 보류 중인 객체를 생성합니다. `vm_alloc_page_with_initializer`에 제공할 `aux` 인수로 `aux` 값을 설정해야 합니다. 이진 파일의 로딩에 필요한 정보를 포함하는 구조체를 만들 수도 있습니다.

```c
static bool lazy_load_segment (struct page *page, void *aux);
```

`load_segment`에서 `vm_alloc_page_with_initializer`의 네 번째 인자로 `lazy_load_segment`가 제공되는 것을 알 수 있습니다. 이 함수는 실행 파일의 페이지를 초기화하는 함수로서 페이지 폴트가 발생할 때 호출됩니다. 이 함수는 페이지 구조체와 aux를 인수로 받습니다. aux는 `load_segment`에서 설정한 정보입니다. 이 정보를 사용하여 세그먼트를 읽어들일 파일을 찾고, 최종적으로 세그먼트를 메모리에 읽어들여야 합니다.

`userprog/process.c` 의 `setup_stack` 함수를 수정하여 새로운 메모리 관리 시스템에 스택 할당을 맞추어야 합니다. 첫 번째 스택 페이지는 게으르게 할당될 필요가 없습니다. 명령줄 인수와 함께 로드 시에 할당하고 초기화할 수 있으며, 이를 폴트가 발생하기를 기다릴 필요가 없습니다. 스택을 식별하는 방법을 제공해야 할 수도 있습니다. `vm/vm.h`의 `vm_type`의 보조 마커 (예: `VM_MARKER_0`)를 사용하여 페이지를 표시할 수 있습니다.

마지막으로 `vm_try_handle_fault` 함수를 수정하여 보충 페이지 테이블을 참조하여 잘못된 주소에 해당하는 페이지 구조체를 해결합니다. 이를 위해 `spt_find_page`를 사용합니다.

요구 사항을 모두 구현한 후에는 fork를 제외한 프로젝트 2의 모든 테스트를 통과해야 합니다.

### ****Supplemental Page Table - Revisit****

이제 우리는 프로세스를 생성하거나 파괴할 때 필요한 복사 및 정리 작업을 지원하기 위해 보충 페이지 테이블 인터페이스를 재방문합니다. 세부 내용은 아래에 설명되어 있습니다. 이 시점에서 보충 페이지 테이블을 다시 방문하는 이유는 위에서 구현한 일부 초기화 함수를 사용하고자 할 수 있기 때문입니다.

**`vm/vm.c`** 안 **`supplemental_page_table_copy`** 와 **`supplemental_page_table_kill`** 를 구현한다.

```c
bool supplemental_page_table_copy (struct supplemental_page_table *dst,
    struct supplemental_page_table *src);
```

src에서 dst로 보충 페이지 테이블을 복사합니다. 이는 자식 프로세스가 부모의 실행 컨텍스트를 상속해야 할 때 사용됩니다 (즉, fork () 일 때). src의 보충 페이지 테이블에서 각 페이지를 반복하고 dst의 보충 페이지 테이블에 해당 항목을 정확히 복사합니다. uninit 페이지를 할당하고 즉시 그들을 claim해야 합니다.

```c
void supplemental_page_table_kill (struct supplemental_page_table *spt);
```

보충 페이지 테이블이 보유하고 있던 모든 리소스를 해제합니다. 이 함수는 프로세스가 종료될 때 호출됩니다 (userprog/process.c의 process_exit() 함수). 페이지 항목을 반복하여 테이블 내의 페이지에 대해 destroy(page)를 호출해야합니다. 이 함수에서는 실제 페이지 테이블 (pml4)과 물리 메모리 (palloc으로 할당된 메모리)에 대해 걱정할 필요가 없습니다. 보충 페이지 테이블이 정리된 후 호출자가 이들을 정리합니다.

### ****Page Cleanup****

 **`vm/uninit.c`** 안에 **`uninit_destroy`** 그리고 `**vm/anon.c**` 안에 **`anon_destroy`** 를 구현한다.

이 함수는 초기화되지 않은 페이지에 대한 해제 작업을 처리합니다. 초기화되지 않은 페이지가 다른 페이지 객체로 변환되더라도 프로세스 종료 시에는 여전히 초기화되지 않은 페이지가 남을 수 있습니다.

```c
static void uninit_destroy (struct page *page);
```

page 구조체가 보유한 자원을 해제합니다. 페이지의 vm 유형을 확인하고 이에 따라 처리하는 것이 좋습니다.

현재는 익명 페이지만 처리할 수 있습니다. 나중에 파일 기반 페이지를 정리하기 위해 이 함수를 다시 살펴볼 것입니다.

```c
static void anon_destroy (struct page *page);
```

익명 페이지가 보유한 자원을 해제합니다. 페이지 구조체를 명시적으로 해제할 필요는 없으며, 호출자가 이를 처리해야 합니다.

**이제 프로젝트 2의 모든 테스트가 통과해야 합니다.**

## Stack Growth

프로젝트 2에서는 프로그램의 스택이 USER_STACK이라는 특정한 주소를 시작으로 하는 단일 페이지로 구성되어 있었습니다. 즉, 프로그램이 사용하는 메모리 공간 중 스택 영역은 이 단일 페이지에 한정되어 있었습니다.

하지만 현재는 스택이 현재 크기를 초과하여 더 많은 메모리가 필요한 경우, 필요한 만큼의 추가 페이지를 할당합니다. 이는 스택이 동적으로 확장될 수 있도록 해주는 기능입니다. 프로그램이 실행 중에 스택이 더 많은 메모리를 필요로 할 때, 추가 페이지가 할당되어 스택의 크기가 확장되어 프로그램이 더 많은 데이터를 스택에 저장할 수 있게 됩니다.

스택 영역에 추가 페이지를 할당하려면, 그 페이지들이 "스택 접근"으로 보여져야 합니다. 이는 추가 페이지가 스택 확장을 위해 사용되기 때문입니다. 하지만 어떤 메모리 접근이 스택 접근인지를 정확히 판단하기 위해서는 휴리스틱(판단 기준)이 필요합니다. 

이 휴리스틱은 스택 접근을 다른 메모리 접근과 구별할 수 있는 기준을 제시하는 것입니다. 즉, 프로그램이 스택을 접근하고 있는지를 식별하기 위한 판단 방법을 개발해야 합니다.

실제 운영 체제에서는 프로세스가 실행 중인 동안 언제든지 인터럽트 혹은 시그널(signal)을 전달할 수 있습니다. 이러한 인터럽트나 시그널은 프로세스의 실행을 중단하고, 예를 들어 메모리에 쓰는 등의 작업을 수행할 수 있습니다. 그런데 이 때 사용자 프로그램이 스택 포인터 아래의 스택에 쓰기를 시도하면, 이러한 인터럽트나 시그널에 의해 스택에 저장된 데이터가 수정될 수 있습니다. 이는 버그로 이어질 수 있는데, 프로그램이 예기치 않은 스택 데이터 변경으로 인해 잘못된 동작을 수행할 수 있기 때문입니다. 따라서 프로그래머는 스택 포인터 아래의 스택 영역에 쓰는 것을 피해야 합니다. 그러나 x86-64 아키텍처에서 PUSH 명령은 스택 포인터를 조정하기 전에 접근 권한을 확인하므로, **스택 포인터로부터 8바이트 아래에 있는 메모리에 대한 페이지 폴트(page fault)가 발생할 수 있습니다.**

시스템 호출 또는 사용자 프로그램에서 발생한 페이지 폴트에서는 syscall_handler() 또는 page_fault()에 전달된 struct intr_frame 구조체의 rsp 멤버를 사용하여 현재의 스택 포인터 값을 얻을 수 있습니다. 이를 통해 현재 스택 포인터 값을 활용할 수 있습니다.

메모리 접근 오류를 감지하기 위해 페이지 폴트를 사용하는 경우, 페이지 폴트가 커널에서 발생하는 경우를 처리해야 한다. 일반적으로 페이지 폴트는 사용자 모드에서 발생하는 오류를 처리하는 데 사용되지만, 가끔은 커널 모드에서도 페이지 폴트가 발생할 수 있습니다. 따라서 이러한 경우에 대비하여 적절한 처리를 수행해야 합니다.

예외가 발생하여 사용자 모드에서 커널 모드로 전환될 때 프로세서가 스택 포인터를 저장한다. 따라서 page_fault() 함수에 전달된 struct intr_frame 구조체에서의 rsp값은 현재 스택 포인터와 다른 값이 들어있을 것이다. 이를 해결하기 위해서는 사용자 모드에서 커널 모드로 초기 전환될 때 rsp를 struct thread에 저장하는 등 다른 방법을 사용하여 사용자 스택 포인터를 얻어야 합니다.

**`Implement stack growth functionalities.`** 

`vm/vm.c` 파일의 `vm_try_handle_fault` 함수를 수정하여 `stack_growth` 를 식별한 후, `vm/vm.c` 파일의 `vm_stack_growth` 함수를 호출하여 스택을 확장해야 한다는. `vm_stack_growth` 함수를 구현해야 합니다.

---

```c
bool vm_try_handle_fault (struct intr_frame *f, void *addr,
    bool user, bool write, bool not_present);
```

> `userprog/exception.c` 파일의 `page_fault` 함수에서 페이지 폴트 예외를 처리하는 동안 호출되는 함수입니다. 이 함수에서는 페이지 폴트가 stack growth에 대한 유효한 경우인지 확인해야 합니다. 만약 폴트가 stack growth로 처리될 수 있는 유효한 경우로 확인되면, 폴트된 주소와 함께 `vm_stack_growth` 함수를 호출해야 합니다.
> 

---

```c
void vm_stack_growth (void *addr);
```

> 이 함수는 `addr`이 더 이상 폴트된 주소가 아닌 상태로 만들기 위해 하나 이상의 익명 페이지를 할당하여 스택 크기를 증가시킵니다. 할당 과정에서 `addr`을 `PGSIZE`로 내림하여 정렬하는 것을 확인하세요.
> 

대부분의 운영체제는 스택 크기에 대한 절대적인 한도를 가지고 있습니다. 일부 운영체제에서는 사용자가 조정 가능한 한도를 제공합니다. 예를 들어, 많은 Unix 시스템에서는 ulimit 명령을 사용하여 조정할 수 있습니다. 많은 GNU/Linux 시스템에서는 기본적으로 8MB로 스택 크기가 제한됩니다. **이 프로젝트에서는 스택 크기를 최대 1MB로 제한해야 합니다.**

이제 모든 stack growth 테스트 케이스가 통과되어야 한다.

## Memory Mapped Files

이 섹션에서는 메모리 맵 페이지(memory-mapped pages)를 구현할 것입니다. Anonymous Page와는 달리 메모리 맵 페이지(memory-mapped pages)는 파일로 백업되는 매핑입니다. 페이지의 내용은 기존 파일의 데이터를 반영합니다. page fault가 발생하면 즉시 physical frame이 할당되고, 파일에서의 내용이 메모리로 복사됩니다. 메모리 맵 페이지가 매핑 해제되거나 swapped out될 때, 내용의 변경은 파일에 반영됩니다.

****`mmap` and `munmap` System Call**

메모리 맵 파일을 위한 두 가지 시스템 호출인 mmap과 munmap을 구현해보겠습니다. VM 시스템은 mmap 에서 페이지를 게으르게 로드하고, 매핑의 백업 저장소로서 mmap된 파일 자체를 사용해야 합니다. 이러한 두 가지 시스템 호출을 구현하기 위해 **`vm/file.c`**에 정의된 **`do_mmap`**과 **`do_munmap`**을 구현하고 사용해야 합니다.

```c
void *mmap (void *addr, size_t length, int writable, int fd, off_t offset);
```

> `offset` byte부터 시작하여 `fd`로 열린 파일을 프로세스의 가상 주소 공간인 `addr`에 길이 바이트로 매핑합니다. 파일의 전체 내용을 `addr`로부터 시작하는 연속적인 가상 페이지에 매핑합니다. 만약 파일의 길이가 `PGSIZE`의 배수가 아니라면, 매핑된 페이지의 일부 바이트는 파일의 끝을 넘어서게 됩니다. 이러한 바이트들은 페이지가 faulted-in 될 때 0으로 설정되며, 페이지가 디스크로 다시 기록될 때는 이러한 바이트들은 삭제됩니다. 성공할 경우, 이 함수는 파일이 매핑된 가상 주소를 반환합니다. 실패한 경우, 유효한 주소로 파일을 매핑할 수 없으므로 NULL을 반환해야 합니다.
> 

`fd`로 열린 파일의 길이가 0바이트인 경우 mmap 호출이 실패할 수 있습니다. 만약 `addr`이 페이지 정렬되지 않았거나, 매핑된 페이지의 범위가 스택이나 실행 파일 로드 시 매핑된 페이지(스택이나 실행 가능한 시간에 매핑된 페이지를 포함)와 겹치는 경우, 이 함수는 실패해야 합니다. 

Linux에서는 만약 **`addr`**이 NULL인 경우, 커널은 매핑을 생성할 적절한 주소를 찾습니다. 단순화를 위해, 주어진 addr에 직접 mmap을 시도할 수 있습니다. 만약 addr이 0인 경우 실패해야 합니다. 왜냐하면 일부 Pintos 코드는 가상 페이지 0이 매핑되지 않은 것으로 가정하기 때문입니다. 또한, length가 0인 경우에도 mmap은 실패해야 합니다.  마지막으로, 콘솔 입력과 출력을 나타내는 파일 디스크립터는 매핑할 수 없습니다. 

메모리 맵 페이지는 익명 페이지와 마찬가지로 게으른(lazy) 방식으로 할당되어야 합니다. **`vm_alloc_page_with_initializer`** 또는 **`vm_alloc_page`**를 사용하여 페이지 객체를 만들 수 있습니다.

---

```c
void munmap (void *addr);
```

> `addr`은 이전에 동일한 프로세스에서 `mmap` 호출로 반환된 가상 주소여야 합니다. 해당 매핑은 아직 매핑 해제되지 않은 상태여야 합니다. `munmap`은 이전에 `mmap`으로 매핑된 주소 범위에 대해 매핑을 해제하는 역할을 수행합니다.
> 

프로세스가 종료될 때, 모든 매핑은 exit 또는 다른 방법으로든 매핑 해제됩니다. **매핑이 해제되면 프로세스에서 수정한 모든 페이지는 해당 파일로 다시 기록되어야 합니다.** **수정되지 않은 페이지는 파일로 기록되지 않아야 합니다. (수정이 되면 dirty bit가 변경됨.)**이는 파일에 해당 페이지의 변경 내용이 반영되지 않음을 의미합니다. 그러면 해당 페이지는 프로세스의 가상 페이지 목록에서 제거됩니다.

파일을 닫거나 삭제하는 것은 파일과 관련된 매핑을 자동으로 해제하지 않습니다. 매핑은 munmap 함수가 호출되거나 프로세스가 종료될 때까지 유효합니다. 이는 유닉스 시스템에서의 관례에 따른 동작입니다.

만약 두 개 이상의 프로세스가 동일한 파일을 매핑한다면, 일관된 데이터를 볼 수 있다는 요구사항은 없습니다. Unix는 이를 처리하기 위해 두 개의 매핑이 동일한 물리적 페이지를 공유하도록 합니다. 또한 `mmap` 시스템 호출에는 페이지를 공유하는지 또는 개인적인지 (즉, 복사 시에만 작성하는지)를 지정할 수 있는 인자가 있습니다. 

(필요에 따라 **`vm/vm.c`**의 **`vm_file_init`** 및 **`vm_file_initializer`**를 수정할 수 있습니다.)

---

```c
void vm_file_init (void);
```

파일을 백업으로 사용하는 페이지 하위 시스템을 초기화합니다. 이 함수에서는 파일 백업 페이지와 관련된 모든 설정을 할 수 있습니다

---

```c
bool file_backed_initializer (struct page *page, enum vm_type type, void *kva);
```

파일 지원 페이지를 초기화합니다. 이 함수는 먼저 `page->operations`에서 파일 지원 페이지에 대한 핸들러를 설정합니다. 페이지 구조체에 백업되는 메모리의 파일과 같은 몇 가지 정보를 업데이트할 수 있습니다.

---

```c
static void file_backed_destroy (struct page *page);
```

연관된 파일을 닫아 파일 백업 페이지를 삭제합니다. 만약 내용이 변경되었다면, 해당 변경 사항을 파일에 다시 기록해야 합니다. 이 함수에서는 페이지 구조체를 해제할 필요가 없습니다. **`file_backed_destroy`**의 호출자가 이를 처리해야 합니다.

## Swap In / Swap Out

메모리 스왑핑은 물리적 메모리의 사용을 최대화하기 위한 메모리 회수 기술입니다. 메인 메모리의 프레임이 할당되면 시스템은 더 이상 사용자 프로그램으로부터의 메모리 할당 요청을 처리할 수 없습니다. 한 가지 해결책은 현재 사용하지 않는 메모리 프레임을 디스크로 교체하는 것입니다. 이렇게 하면 일부 메모리 리소스가 해제되고 다른 애플리케이션에서 사용할 수 있게 됩니다.

스왑은 운영 체제에서 수행합니다. 시스템이 메모리가 부족함을 감지하고 메모리 할당 요청을 받으면 스왑 디스크로 내보낼 페이지를 선택합니다. 그런 다음 메모리 프레임의 정확한 상태가 디스크에 복사됩니다. 프로세스가 스왑된 페이지에 접근하려고 할 때, 운영 체제는 정확한 내용을 메모리로 다시 가져와서 페이지를 복구합니다. 선택된 페이지는 익명 페이지(anonymous page)일 수도 있고, 파일을 백업한 페이지(file-backed page)일 수도 있습니다. 이 섹션에서는 각각의 경우를 처리할 것입니다.

모든 스왑 작업은 명시으로 호출되는 것이 아니라 함수 포인터로 처리됩니다. 이들은 각 페이지의 이니셜라이저에 대한 연산으로 등록될 `struct page_operations file_ops`의 멤버입니다.

****Anonymous Page****

`vm/anon.c` 파일의 `vm_anon_init` 및 `anon_initializer`를 수정하십시오. 

익명 페이지는 자체적인 백업 저장소를 가지고 있지 않습니다. 익명 페이지의 스왑 지원을 위해 스왑 디스크라는 임시 백업 저장소를 제공합니다. 익명 페이지의 스왑을 구현하기 위해 스왑 디스크를 활용할 것입니다.

```c
void vm_anon_init (void);
```

이 함수에서는 스왑 디스크를 설정해야 합니다. 또한 스왑 디스크에서 사용 가능한 영역과 사용 중인 영역을 관리하기 위한 데이터 구조가 필요합니다. 스왑 영역은 `PGSIZE` (4096 바이트) 단위로 관리됩니다.

```c
bool anon_initializer (struct page *page, enum vm_type type, void *kva);
```

이것은 익명 페이지의 초기화 함수입니다. 스왑 지원을 위해 익명 페이지에 몇 가지 정보를 추가해야 합니다.

이제 익명 페이지에 대한 스왑을 지원하도록 `vm/anon.c`에서 `anon_swap_in` 및 `anon_swap_out`을 구현합니다. 페이지를 스왑 인하려면 페이지를 스왑 아웃해야 하므로 `anon_swap_in`을 구현하기 전에 `anon_swap_out`을 구현하는 것이 좋습니다. 데이터 내용을 스왑 디스크로 옮긴 다음 안전하게 메모리로 다시 가져와야 합니다.

```c
static bool anon_swap_in (struct page *page, void *kva);
```

디스크의 데이터 내용을 읽어 메모리로 가져와 스왑 디스크로부터 익명 페이지를 Swaps in합니다. 페이지가 스왑아웃될 때, 데이터의 위치는 페이지 구조체에 스왑 디스크에 저장되어 있어야 합니다. 스왑 테이블을 업데이트하는 것을 잊지 마세요. (스왑 테이블 관리 참조)

```c
static bool anon_swap_out (struct page *page);
```

메모리의 내용을 디스크로 복사하여 익명 페이지를 스왑 디스크로 스왑아웃합니다. 먼저 스왑 테이블을 사용하여 디스크에서 사용 가능한 스왑 슬롯을 찾은 다음 데이터 페이지를 슬롯에 복사합니다. 데이터의 위치는 페이지 구조체에 저장되어야 합니다. 디스크에 더 이상 빈 슬롯이 없는 경우 커널을 패닉 상태로 만들 수 있습니다.

****File-Mapped Page****

파일 백업 페이지의 용은 파일에서 가져오므로, `mmap` 된 파일을 백업 저장소로 사용해야 합니다. 즉, 파일 지원 페이지를 대체하면 해당 페이지는 원래 매핑된 파일로 다시 기록됩니다. `vm/file.c`에서 `file_backed_swap_in` 및 `file_backed_swap_out`을 구현하세요. 당신의 설계에 따라 `file_backed_init` 및 `file_initializer`를 수정할 수 있습니다.

```c
static bool file_backed_swap_in (struct page *page, void *kva);
```

kva 위치에 있는 페이지를 파일로부터 읽어와서 스왑인하는 함수입니다. 파일 시스템과 동기화해야 합니다.

```c
static bool file_backed_swap_out (struct page *page);
```

페이지의 내용을 파일에 다시 쓰면서 페이지를 스왑아웃합니다. 먼저 페이지가 더럽지 않은지(check if the page is dirty) 확인하는 것이 좋습니다. 파일이 더럽지 않다면 파일의 내용을 수정할 필요가 없습니다. 페이지를 스왑아웃한 후, 페이지의 dirty 비트를 꺼놓는 것을 잊지 마세요.

---

## Memory Allocation

pintos는 두 개의 메모리 할당기를 포함하고 있다. 하나는 페이지 단위로 메모리를 할당하고, 다른 하나는 원하는 크기의 블록을 할당할 수 있는 메모리 할당기이다. (palloc과 malloc)

### Page Allocator

`include/threads/palloc.h` 에 선언된 페이지 할당기는 페이지 단위로 메모리를 할당하는 기능을 가지고 있으며, 일반적으로 한 번에 한 페이지씩 메모리를 할당하는 데 사용된다. 그러나 필요에 따라 한 번에 여러 개의 연속된 페이지를 할당할 수도 있다.

페이지 할당기는 할당하는 물리 메모리를 커널 풀과 유저 풀이라고 불리는 두 개의 풀로 나눈다. 기본적으로 각 풀은 1MB 이상의 시스템 메모리의 절반을 할당받지만, ul 커널 커맨드 라인 옵션을 사용하여 분할을 변경할 수 있다. 유저 풀은 유저 프로세스에 대한 메모리 할당에 사용되어야 하며, 커널 풀은 다른 모든 할당에 사용되어야 한다. 이는 프로젝트 3부터 중요해진다. 그 전까지는 모든 할당은 커널 풀에서 이루어진다.

각 풀의 사용 상태는 비트맵으로 추적된다. 풀 내의 각각의 페이지에는 하나의 비트가 있다. n개의 페이지를 할당하는 요청은 비트맵을 n개의 연속된 false로 설정된 비트를 검사하여 해당 페이지가 사용 가능하다는 것을 나타내며, 그 비트를 true로 설정해서 사용중으로 표시한다.

페이지를 할당기는 단편화 문제에 영향을 받는다. 즉 n개 이상의 페이지가 비어 있어도 현재 사용 중인 페이지로 인해서 n개의 연속된 페이지를 할당할 수 없을 수도 있다. 극단적인 경우에는 풀의 절반 이상의 페이지가 비어 있더라도 2개의 연속된 페이지를 할당하는 것이 불가능할 수도 있다. 단일 페이지 요청은 단편화로 인한 문제가 발생하지 않기 때문에 괜찮지만, 연속된 여러 페이지를 요청하는 경우는 위같은 문제를 발생시키기 때문에 최대한 제한해야 한다.

인터럽트 컨텍스트(즉 인터럽트가 발생했을 경우)에서는 페이지를 할당할 수는 없지만, 해제할 수는 있다.

페이지가 해제될 때 (palloc_free_page) 해당 페이지의 모든 바이트는 0xcc 값으로 설정되어 초기화된다.

페이지 할당과 관련된 함수는 다음과 같다.

---

```c
void *palloc_get_page (enum palloc_flags flags)
void *palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
```

> 하나의 페이지를 얻어서 반환하거나, page_cnt 만큼의 연속된 페이지를 얻어서 반환한다. 페이지를 할당할 수 없는 경우 null 포인터를 반환한다.
> 
> 
> ***flags* 인자는 다음 플래그들의 조합일 수 있다**:
> 
> - `PAL_ASSERT`
>     
>     페이지를 할당할 수 없는 경우 커널을 패닉 상태로 전환. 이는 주로 커널 초기화 중에만 적절하다. 사용자 프로세스는 커널을 패닉 상태로 전환시키는 것이 허용되지 않아야 한다.
>     
> - `PAL_ZERO`
>     
>     할당된 페이지의 모든 바이트를 0으로 설정한 후 반환한다. 설정되지 않은 경우, 새롭게 할당된 페이지의 내용은 예측할 수 없다.
>     
> - `PAL_USER`
>     
>     사용자 풀에서 페이지를 얻는다. 설정되지 않은 경우, 페이지는 커널 풀에서 할당된다.
>     

---

```c
void palloc_free_page (void *page)
void palloc_free_multiple (void *pages, size_t page_cnt)
```

> 페이지를 하나 또는 연속된 페이지 개수만큼 해제한다. 해제할 페이지는 모두 palloc_get_pate() 또는 palloc_get_multiple()을 사용해서 얻은 페이지이여야 한다.
> 

---

### Block Allocator

## Hash Table

Pintos는 `lib/kernel/hash.c` 에 해시 테이블 자료 구조를 제공합니다. 이를 사용하기 위해서는 `#include <hash.h>` 와 같이 해당 헤더 파일인 `lib/kernel/hash.h` 를 포함해야 합니다. Pintos와 함께 제공되는 코드 중에서는 해시 테이블을 사용하는 부분이 없기 때문에, 사용자는 원하는 대로 해시 테이블을 사용하거나 수정하여 필요에 맞게 구현하거나 무시할 수 있습니다.

Project3의 대부분 구현에서는 페이지를 프레임에 매핑하기 위해 해시 테이블을 사용합니다. 또한, 해시 테이블을 다른 용도로 활용할 수도 있습니다.

### Data Types

해시 테이블은 구조체 hash로 표현됩니다.

---

```c
struct hash;
```

> 해시 테이블 전체를 나타냅니다. struct hash의 실제 멤버들은 "불투명"합니다. 즉, 해시 테이블을 사용하는 코드는 struct hash 멤버에 직접 접근하거나 접근할 필요가 없어야 합니다. 대신 해시 테이블 함수와 매크로를 사용하세요.
> 

해시 테이블은 `struct hash_elem` 타입의 엘리먼트에 대해서만 동작합니다.

---

```c
struct hash_elem;
```

> 해시 테이블에 포함시키려는 구조체에 struct hash_elem 멤버를 내장시키세요. struct hash_elem은 struct hash와 마찬가지로 불투명합니다. 실제로 해시 테이블 원소를 조작하는 모든 함수는 실제 원소 타입이 아니라 struct hash_elem에 대한 포인터를 인자로 받고 반환합니다.
> 

해시 테이블의 실제 원소를 기반으로 `struct hash_elem`을 얻거나 그 반대의 작업을 수행해야 할 때가 많습니다. 해시 테이블의 실제 원소가 주어졌을 때는 & 연산자를 사용하여 해당 원소의 `struct hash_elem`에 대한 포인터를 얻을 수 있습니다. 그 반대로 진행할 때는 `hash_entry()` 매크로를 사용하세요.

---

```c
#define hash_entry (elem, type, member) { /* Omit details */ }
```

> elem이 struct hash_elem에 대한 포인터인 구조체 내에 포함된 구조체의 포인터를 반환합니다. elem이 속한 구조체의 이름인 type과 elem이 가리키는 type 내의 멤버인 이름인 member를 제공해야 합니다.

예를 들어, h가 struct hash_elem * 타입의 변수이고 h_elem이라는 struct thread 멤버(타입은 struct hash_elem)를 가리키는 경우, hash_entry(h, struct thread, h_elem)은 h가 가리키는 struct thread의 주소를 반환합니다.
> 

각 해시 테이블 요소는 고유해야 하는, 즉 요소들 사이에서 식별 및 구분을 할 수 있는 데이터인 키(key)를 포함해야 합니다. (요소는 고유하지 않아도 되는 비-키 데이터를 포함할 수도 있습니다.) 해시 테이블에 요소가 있는 동안에는 키 데이터를 변경해서는 안 됩니다. 대신, 필요한 경우 요소를 해시 테이블에서 제거하고 키를 수정한 후에 요소를 다시 삽입해야 합니다.

각 해시 테이블마다 키(key)에 작용하는 두 가지 함수를 작성해야 합니다: 해시 함수(hash function)와 비교 함수(comparison function). 이러한 함수들은 다음의 원형(프로토타입)과 일치해야 합니다.

---

```c
typedef unsigned hash_hash_func (const struct hash_elem *e, void *aux);
```

> element의 데이터에 대한 해시 값을 unsigned int 범위 내의 어떤 값으로 반환합니다. 해시 값은 random해야 한다. 해시 값은 요소의 키 이외의 키가 아닌 데이터나 키 이외의 비-상수 데이터에 의존해서는 안 됩니다. Pintos는 해시 함수에 적합한 기반이 되는 다음 함수들을 제공합니다.
> 
- `unsigned hash_bytes (const void *buf, size t *size)`
    
    > element의 데이터에 대한 해시 값을 unsigned int 범위 내의 어떤 값으로 반환합니다.
    > 
- `unsigned hash_string (const char *s)`
    
    > 정수 i의 해시값을 반환한다.
    > 
- `unsigned hash_int (int i)`
    
    > 정수 i의 해시값을 반환한다.
    > 

만약 키가 적절한 유형의 단일 데이터인 경우, 해시 함수가 이러한 함수 중 하나의 출력을 직접 반환하는 것이 합리적입니다. 여러 개의 데이터 조각의 경우에는 '^' (배타적 논리합) 연산자를 사용하여 이러한 함수 호출의 출력을 조합할 수 있습니다. 마지막으로, 이러한 함수를 완전히 무시하고 처음부터 직접 해시 함수를 작성할 수도 있지만, 목표는 운영 체제 커널을 구축하는 것이므로 해시 함수를 설계하는 것이 목표는 아닙니다. aux에 대한 설명은 [해시 보조 데이터] 섹션을 참조하세요.

- `bool hash_less_func (const struct hash_elem *a, const struct hash_elem *b, void *aux)`
    
    > 요소 a와 b에 저장된 키를 비교합니다. a가 b보다 작으면 true를 반환하고, a가 b보다 크거나 같으면 false를 반환합니다. 두 요소가 동일하게 비교되는 경우, 해시 값도 동일해야 합니다.
    **`aux`**에 대한 설명은 [Hash Auxiliary Data] 섹션을 참조하십시오. 해시 및 비교 함수 예제는 [Hash Table Example] 섹션을 참조하십시오. 몇 가지 함수는 인자로 세 번째 종류의 함수에 대한 포인터를 받습니다.
    > 
- `void hash_action_func (struct hash_elem *element, void *aux)`
    
    > 호출자가 선택한 동작을 element에 대해 수행합니다. aux에 대한 설명은 [Hash Auxiliary Data] 섹션을 참조하십시오.
    > 

## * Virtual memory management

- **paging**
    
    가상 메모리를 고정된 크기의 page 단위로 나누어서(고정 분할 방식) 관리하는 기법.
    
    - **virtual page**
        - 가상 페이지는 모두 같은 크기를 가진다. → 페이지 크기는 하드웨어에 의해 정해지고 일반적으로 2의 제곱수를 사용한다.
        - 페이지 테이블을 이용해서 가상 메모리 주소에서 물리 메모리 주소로 매핑한다.
    - **physical frame**
        - 물리 메모리 공간을 페이지와 같은 사이즈로 나눈 것을 프레임이라고 한다.
        - 프레임 크기도 페이지 사이즈와 동일하게 하드웨어에 의해 정해진다.
    - **page table & supplementary page table**
        - 페이지 테이블은 가상 메모리 상의 페이지를 물리 메모리 상의 프레임으로 매핑시켜주는 정보를 담고 있는 테이블이며, 모든 프로세스는 페이지 테이블을 가진다.
        - 페이지 테이블은 메인 메모리에 저장된다.
        - Page Table Base Register(PTBR)가 페이지 테이블을 가리키고, Page Table Length Register(PTLR)가 페이지 테이블의 크기를 가리킨다. → 이러한 레지스터들의 내용은 PCB에 저장되어 있다.(+ Context Switching이 일어날 때 교체된다.)
        - supplementary page table
            - 페이지 테이블을 보완하는 역할을 수행하는 데이터 구조이다. 즉, 페이지 테이블에는 없는 추가적인 데이터를 저장한다. → 페이지 테이블의 제약사항 극복, 더 많은 정보 관리 가능
            - 일반적으로 **페이지 폴트 처리**와 **자원 해제**와 같은 목적으로 사용된다.
- **Memory Management Unit (MMU)**
    
    메모리 관리 장치의 약자, 가상 메모리와 물리 메모리 간의 주소 변환을 담당하는 하드웨어 장치이다. 일반적으로 페이지 테이블을 사용해서 가상 주소를 물리 주소로 매핑한다. 페이지 테이블은 가상 메모리 공간을 페이지로 분할하고, 각 페이지에 대한 매핑 정보를 저장한다. MMU는 이러한 페이지 테이블을 참조해서 가상 메모리 주소의 페이지 번호를 확인하고 해당 페이지 번호에 대한 물리 메모리의 프레임을 찾아내서 실제 메모리 위치로 변환한다.
    
- **Translation Lookaside Buffer (TLB)**
    
    주소 변환 캐시라고 불리는 TLB는 MMU와 함께 동작하며, 가상 메모리 주소를 물리 메모리 주소로 변환하는 과정에서의 성능을 향상시키기 위해 사용되는 캐시이다. 페이지 테이블은 메인 메모리에 저장되어 있기 때문에 접근 시간이 상대적으로 오래 걸릴 수 있는데, 이런 경우 매번 페이지 테이블을 참조하여 가상 주소를 물리 주소로 변환하는 것은 비효율적일 수 있다. 이러한 문제를 해결하기 위해서 TLB가 사용된다. MMU가 주소를 변환할 때 먼저 TLB를 검사하여 가상 메모리 주소의 매핑 정보를 찾아보고, 정보가 존재한다면 메모리에 접근하지 않고 해당 물리 메모리 주소를 반환한다. 이로써 주소 변환에 필요한 메모리 액세스 시간을 크게 단축시킬 수 있다.
    
    - 가장 최근에 사용된 가상 메모리 주소의 매핑 정보를 저장한다.
    - TLB miss - TLB에 찾는 매핑 정보가 없을 때 발생.

## * Page type

- **Uninitialized page**
    
    프로세스의 가상 메모리 공간에서 사용되는 페이지 중 초기화 되지 않은 데이터를 포함하고 있는 페이지를 말한다. 프로세스가 실행되는 동안 데이터 페이지나 스택 페이지에는 초기화된 값이 할당되어 있지만, 힙 페이지나 BSS(Bloack Started by Symbol) 영역에 해당하는 페이지는 초기화되지 않은 상태로 할당될 수 있다. 이러한 페이지에는 초기화되지 않은 데이터나 전역 변수들이 위치하게 된다. 미초기화 페이지는 해당 페이지에 접근할 때 초기화되지 않은 값이 존재할 수 있으므로 주의해야 한다. 프로세스가 미초기화 페이지를 사용할 때는 반드시 초기화 작업을 통해 적절한 값을 할당해야 정확하고 안정적인 동작을 보장할 수 있다.
    
    - **Lazy initialization**
        
        초기화되어야 할 값이 실제로 필요한 시점까지 지연되는 초기화 방식을 말한다. 이는 프로그램 실행 시 모든 데이터를 한 번에 초기화 하는 대신에 해당 데이터에 처음으로 접근하는 시점에서 초기화를 수행하는 것을 의미한다. 
        
        이는 대규모의 데이터나 복잡한 시스템에서 초기화에 많은 시간이 소요되는 경우에 유용한 기법이다. 주의해야 할 점은 초기화가 필요한 데이터에 접근하기 전에 초기화 작업이 꼭 수행되어야 하며, 그렇지 않을 시에는 잘못된 동작이 발생할 수 있다.
        
- **Anonymous page**
    
    익명 페이지는 가상 메모리 시스템에서 파일이나 스왑 공간에 연결되지 않은 메모리 페이지를 말한다. 이러한 페이지는 주로 프로세스의 스택, 힙, BSS 등과 같은 프로세스 메모리 공간에 할당되며, 디스크에 저장된 파일과 직접적인 연관성을 갖지 않는다.
    
    익명 페이지의 특징과 동작 방식은 다음과 같다.
    
    1. 파일과 연결되지 않음 : 익명 페이지는 디스크에 저장된 파일과 연결되지 않는다. 따라서 해당 페이지는 파일 시스템에서 읽어오는 것이 아니라, 프로세스 메모리 공간 내에서 동적으로 생성된다.
    2. 초기화되지 않음 : 익명 페이지는 일반적으로 파일에 저장된 데이터로 초기화 되지 않는다. 초기화 되지 않은 페이지는 0 또는 임의의 값으로 채워지며, 프로세스가 필요에 따라 해당 페이지에 데이터를 쓰는 것이 가능하다.
    3. 스택과 힙 할당 : 프로세스의 스택과 힙 영역은 익명 페이지를 사용하여 동적으로 메모리를 할당한다. 프로세스의 스택은 호출된 함수와 지역 변수를 저장하는데 사용되며, 힙은 동적으로 할당된 메모리를 관리하는데 사용된다.
    4. 페이지 교체 및 스왑 : 익명 페이지는 페이지 교체 정책에 따라 메모리가 관리된다. 메모리가 부족한 경우 페이지 교체 알고리즘에 따라 일부 익명 페이지가 메모리에서 스왑 영역으로 스왑아웃 될 수 있다. 이렇게 스왑된 페이지는 나중에 다시 필요할 때 스왑인 되어 메모리로 복구 된다.
    5. 메모리 보호 : 익명 페이지는 일반적으로 읽기-쓰기-실행 가능한 권한을 가지며, 프로세스가 해당 페이지에 엑세스할 수 있다. 그러나 필요에 따라 읽기 전용 권한으로 설정하여 프로세스가 페이지의 내용을 수정하지 못하도록 할 수도 있다.
    6. 메모리 공간 공유 : 여러 프로세스가 동일한 프로그램을 실행하는 경우, 익명 페이지를 공유하여 메모리 공간을 공유할 수 있다. 이를 통해 여러 프로세스가 동일한 페이지를 메모리에 로드하지 않고 메모리 사용량을 줄이고 성능을 향상시킬 수 있다.
    - **stack growth**
        
        프로그램이의 실행 도중 스택 영역이 확장되는 것을 의미한다. 즉, 스택의 크기를 동적으로 조정하여 프로세스가 필요로 하는 추가적인 스택 공간을 확보하는 과정이다. 
        
        1. 스택 상향 : 스택이 낮은 주소에서 높은 주소로 성장하는 방식에서 스택의 크기가 상단으로 확장됨
        2. 스택 하향 : 스택이 높은 주소에서 낮은 주소로 성장하는 방식에서 스택의 크기가 하단으로 확장됨.
- **file-backed page**
    
    가상 메모리에서 실제 데이터를 파일에 저장하고 필요할 때 해당 파일에서 데이터를 로드하는 페이지이다. 일반적으로 메모리 매핑을 통해 구현된다.
    
    메모리 매핑은 파일의 내용을 가상 메모리 공간에 직접 매핑해서 파일의 데이터에 접근할 수 있도록 한다. 이는 파일을 메모리에 올리는 데에 필요한 디스크 I/O 작업을 줄여준다. 
    
    - **mmap syscall**
        
        파일을 가상 메모리에 매핑하는 데 사용되는 시스템 콜. mmap을 통해 파일을 메모리에 매핑하면 해당 파일의 데이터를 현재 가상 메모리에서 직접 접근할 수 있다.
        
        즉, mmap 호출을 통해서 파일을 메모리에 매핑하면 File-backed page를 생성할 수 있다.
        

## * Swap in/out

스왑 인과 스왑 아웃은 주기억장치와 보조기억장치 간의 데이터 이동을 뜻한다. 

1. **Swap Out**
    
    주기억장치에 있는 페이지 중에서 더  이상 사용되지 않는 페이지를 선정하여 보조기억장치로 옮긴다. 이는 주기억장치의 여유 공간을 확보하거나 페이지 교체 정책에 따라 새로운 페이지를 올리기 위해서이다. 스왑 아웃된 페이지는 주기억장치에서 해제되고, 해당 페이지를 저장하기 위해 보조기억장치의 스왑 영역에 저장된다.
    
2. **Swap In**
    
    보조기억장치에서 주기억장치로 페이지(또는 프레임)를 되돌리는 작업을 뜻한다. 주기억장치에 필요한 페이지가 없는 경우에 해당 페이지를 보조기억장치의 스왑영역에서 다시 주기억장치로 가져온다.
    
- **page replacement policy**
    
    페이지 교체 정책은 주기억장치에서 스왑 아웃될 페이지를 선택하는 알고리즘을 뜻한다. 이를 통해 page fault를 최소화하고 성능과 공정성을 균형 있게 유지하고자 한다.
    
    1. **FIFO (First-In, First-Out)**:
        - FIFO 알고리즘은 가장 오래된 페이지를 스왑 아웃하는 방식
        - 주기억장치에 올라온 순서대로 페이지를 유지하고, 가장 먼저 주기억장치에 들어온 페이지를 스왑 아웃.
    2. **LRU (Least Recently Used)**:
        - LRU 알고리즘은 가장 오랫동안 참조되지 않은 페이지를 스왑 아웃하는 방식
        - 페이지의 최근 접근 기록을 유지하고, 가장 오랫동안 참조되지 않은 페이지를 스왑 아웃
    3. **LFU (Least Frequently Used)**:
        - LFU 알고리즘은 가장 적게 참조된 페이지를 스왑 아웃하는 방식
        - 페이지의 참조 횟수를 계산하고, 가장 적게 참조된 페이지를 스왑 아웃
    4. **MFU (Most Frequently Used)**:
        - MFU 알고리즘은 가장 많이 참조된 페이지를 스왑 아웃하는 방식
        - 페이지의 참조 횟수를 계산하고, 가장 많이 참조된 페이지를 스왑 아웃
    5. **Optimal**:
        - Optimal 알고리즘은 가장 최적의 페이지를 스왑 아웃하는 방식
        - 미래의 참조 패턴을 가정하고, 가장 오랫동안 사용되지 않을 페이지를 스왑 아웃
        - 이 알고리즘은 이론적으로 가장 좋은 성능을 제공하지만, 실제로는 구현이 어렵고 예측이 어려워 사용되기 힘듬
- **swap disk**
    
    스왑 디스크(Swap Disk)는 운영체제에서 가상 메모리 관리를 위해 사용되는 보조 저장 장치입니다. 주 기억장치(RAM)의 용량이 제한적일 때, 운영체제는 주기억장치에 올라가지 않은 페이지를 스왑 디스크에 저장하여 추가 공간을 확보한다. 스왑 디스크는 주 기억장치와 비교하여 용량이 크고, 비교적 느린 접근 속도를 가지는 특징이 있다.
    

# ✅ TEAM WIL

---

<aside>
💡 Pintos Project3 : Virtual Memory (team 8)

</aside>

## ‼️ 주요 학습 내용

## ‼️ 특이점

- `64bit` 컴퓨터 시스템에서의 4단계 페이징 방식
- pintos가 부팅될 때 페이징 초기화 → `init.c/paging_init` 을 살펴보자.
- `pml4`가 물리 메모리 주소에 할당되는 이유에 대해?
- `spt`를 해시 테이블로 만들고자 할 때?
    - `spt`에 테이블 필드를 넣어준다.
    - `spt`의 각 원소들 즉, spt_entry = page이다.
        - 기존에 사용해왔던 hash table 구조와는 다름. buckets → bucket → page
    - `hash.h`를 보고 해시 테이블을 조작하는 방식에 대해 파악해야 한다.
- `lazy_load_segment()` 는 읽은 파일의 페이지를 생성해서 물리 메모리 주소에 할당해주는 역할인데, 페이지 테이블의 엔트리를 가져와서 이상한 작업을 해주고 있었음.
- `fork()` 호출 시 자식 프로세스가 생성될 때 부모 스레드의 spt를 복사할 때 부모 스레드의 초기 페이지 수와 복사할때 페이지 수가 다른 이유? user stack 페이지가 추가됨.
- 현재 `setup_stack()`에서 스택 페이지를 할당해줄 때 마커로 스택 페이지임을 표시해주면 오류가 발생하고 있음. → `vm_alloc_page_with_initializer()`에서 `type`을 체크할 때 `VM_TYPE()`을 이용해야 한다.
- `rsp`는 현재 스택 영역의 최상단을 가리키고 있다. `PUSH`, `POP` 명령어는 `rsp`를 8byte씩 증감 시킨다.
- `mmap`에서 파일에 대한 매핑이 된 페이지 또한 lazy load되어야 했기 때문에.. 기존 `lazy load` 함수를 사용해서 구현했다. (`VM_TYPE` 이 `VM_FILE`인 페이지와 `VM_ANON` 페이지 와의 차이는 실제로 읽은 바이트 수의 유효성이라고 할 수 있다.)
- union 타입은 한 구조체당 한 타입만 유효하다. (갱신 시 기존 타입 변함.)
- 페이지를 읽기 작업으로만 사용하면 더티 비트는 설정되지 않고, 페이지를 쓰기 작업으로 변경하는 경우 더티 비트가 설정됨. 따라서, 더티 비트가 설정된 페이지는 수정되었다는 의미이며, 더티 비트가 해제된 페이지는 수정되지 않았다는 의미이다.
- `vm_try_fault_handler()` 내부에서 `not_present`가 `true`일 떄만 페에지를 생성해줘야 한다. 이걸 수정하면 `pt-write-code` 와 `mmap-ro` 가 성공함. `code segment`관한 문제 ?
    - kpage는 page fault가 나더라도 vm_get_frame이 발생하면 안된다.
- `fork()`를 통해서 자식 프로세스를 생성하고 자식 프로세스 내에서 `mmap`을 통해 파일을 매핑해서 사용한다음 munmap 호출 없이 자식 프로세스가 종료되었을 때, 처리가 안되고 있었음. →  `destroy_func`에서 처리해주어야 함.

## ‼️ Trouble shooting

### PANIC : todo 오류

****Anonymous Page****의 Setup Stack까지 구현하고 테스트를 하니 PANIC : todo가 떴다. 

![화면 캡처 2023-06-18 202935.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_202935.png)

todo는 vm_get_frame에서 유저풀에 빈 페이지 공간을 할당 수 없을 때 PANIC이 뜨게 설정을 해주었다. 그래서 printf(”a”)를 찍어보니 

![화면 캡처 2023-06-18 203705.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_203705.png)

이런 식으로 엄청 많은 a가 찍혀있었다.

그래서 `palloc_get_page`에서 계속 할당을 해주니 더 이상 할당을 할 수 없어서 PANIC이 뜬다고 생각해서 코드를 찾아보니 `pml4_set_page` 에서 PML4에 가상 주소와 물리 주소를 매핑하는데 여기서 새 페이지의 권한을 줄 수 있다.

여기서 FLASE를 줄 때는

![화면 캡처 2023-06-18 212753.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_212753.png)

page의 가상 주소가 모두 같은 값으로 나온다.

하지만 TRUE를 줄 때는

![화면 캡처 2023-06-18 212907.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-18_212907.png)

page의 가상 주소가 다른 값으로 나온다.

그래서 아마도 FALSE를 줄 때 page→va가 계속 같은 값이 나와서 PML4에 계속 같은 값을 매핑 시켜 줄려고 하면 page fault가 뜨고 다시 `vm_do_claim_page`에 들어가서 계속 무한루프가 발생하는 것 같다.

### **Stack growth을 할 때 시스템 콜에서 rsp를 저장하는 이유**

깃북에 이런 글이 적혀 있다.

![화면 캡처 2023-06-26 025415.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-26_025415.png)

간단하게 번역을 하면 커널에 의한 접근의 rsp값은 user stack포인터가 아닌 정의 되지 않은 값을 반환하기 때문에 rsp를 사용자 모드에서 커널모드로 처음 전환할 때 스레드 구조체에 저장해주라는 말이다.

그래서 이거에 맞는 코드를 작성을 해주었다.

![화면 캡처 2023-06-26 033212.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-26_033212.png)

시스템 콜 헨들러에 rsp를 갱신 시켜주고

![화면 캡처 2023-06-26 033443.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-26_033443.png)

페이지 폴트 헨들러에 user에 의한 접근이 아니면 스레드에 저장되있는 rsp를 가져왔다.

이때 어떤 테스트 케이스에 걸리는지 궁금해서 프린트 문을 찍고 make check를 돌려봤다. 

![화면 캡처 2023-06-26 034648.png](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25ED%2599%2594%25EB%25A9%25B4_%25EC%25BA%25A1%25EC%25B2%2598_2023-06-26_034648.png)

전부 돌려봤지만 커널에서 사용되는 rsp가 if(!user)을 통과해서 stack growth를 통과하는 경우를 찾지 못했다.

아마도 해줘야한는 경우가 분명히 존재하지만 테스트 케이스로 만들기는 힘들거나 만들 수 없는 경우여서 깃북에 명시해두는걸로 마무리 하는것이 아닐까 생각하고 있다.

### anonymous page swap error

spt_find_page() 함수 내에서 임시 페이지를 할당받고, 해시 테이블에서 페이지를 찾은 후에 임시 페이지(temp_page)를 free() 해주지 않는 것이 문제가 됐고, swap_anon 테스트가 실패했음.

![문제의 free()](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.40.37.png)

문제의 free()

### 페이지의 수정여부를 확인하는 법

`munmap()`을 구현하면서 매핑이 해제될 때, 각각의 페이지가 수정되었는지 여부를 판단해서 수정이 되었다면, 해당 페이지에 대응하는 부분을 덮어써주어야 했다. 해당 페이지가 수정되었는지 확인하기 위해서는 해당페이지 테이블 엔트리의 더티 비트를 사용한다. 즉 페이지가 수정되었을 때, 해당 비트가 1로 설정되기 때문에, 이를 통해서 수정 여부를 확인할 수 있는 것이다.

![더티 비트에 따른 overwrite 설정.](%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%E1%84%90%E1%85%A9%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%B3%E1%86%AF%20Week%2010%20017ec9e6b2b1497faace74d97a4682e4/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-06-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.59.26.png)

더티 비트에 따른 overwrite 설정.

처음엔  `write()` 시스템콜 내에서 직접 더티 비트를 설정해주어야 하는 줄 알았지만 일반적으로 더티 비트는 cpu를 통해 갱신된다. cpu는 메모리 액세스를 수행할 때 페이지 테이블 엔트리를 참조해서 액세스할 메모리 위치를 결정하는데 이 때 페이지가 수정되었다면(쓰기 작업이 수행되었을 때) CPU는 해당 페이지 테이블 엔트리의 더티 비트를 설정하도록 하드웨어에 요청한다. 이는 일반적으로 페이지 테이블 엔트리의 특정 비트를 플립하는 방식으로 이루어진다. (하지만 overwrite 해준 후에 더티 비트를 0으로 되돌려 놓아주는 것은 운영체제의 역할.)

수정 여부를 더티비트를 사용해서 판단한다는 것은 알았다. 하지만 파일이 create() 되었을 때도 더티비트가 설정될까? 답은 NO. 즉 파일을 생성했을 때는 파일의 데이터가 메모리에 로드되지 않으므로 페이지 테이블 엔트리의 더티 비트는 설정되지 않지만, 생성 후에 해당 파일에 데이터를 쓰는 순간? 더티 비트가 설정되게 된다. 

추가적으로 VM_FILE 타입의 페이지가 스왑 아웃될 때도 더티 비트를 사용해서 overwrite가 수행된다.

## ‼️ 회고

- 🐶 힘들었음.
